---
type: "always_apply"
description: "动态思考深度调节 - 基于任务复杂度和用户需求智能调节AI思考深度"
globs: ["**/*"]
alwaysApply: true
priority: 1150

# Version Management
version: "2.6.0"
last_updated: "2025-10-19"
author: "system"
status: "stable"
compatibility: "rule-system >= 2.0"

changelog:
  - version: "2.6.0"
    date: "2025-10-19"
    changes:
      - "P2-11: 新增评分算法实现细节(附录A)"
      - "实现3个维度评分计算方法(Python函数)"
      - "添加上下文因子计算(0.5-1.5调节)"
      - "提供2个完整评分示例(Level 1和Level 5)"
      - "建立实时权重调节机制"
---

# 🎯 动态思考深度调节机制 (Dynamic Thinking Depth Regulation)

## 一、核心理念

### 1.1 自适应认知原理
基于认知心理学和计算认知科学，建立智能化的思考深度调节机制，实现：
- **认知资源优化配置**: 根据任务需求动态分配思维资源
- **效率与质量平衡**: 在速度和准确性之间找到最优平衡点
- **上下文敏感调节**: 基于用户需求和情境特征调整思考策略
- **元认知自我监控**: 持续评估和优化思考过程的有效性

### 1.2 多维度评估框架
```
任务复杂度评估维度:
1. 认知复杂度 (Cognitive Complexity)
2. 信息密度 (Information Density) 
3. 不确定性程度 (Uncertainty Level)
4. 时间敏感性 (Time Sensitivity)
5. 风险等级 (Risk Level)
6. 创新要求 (Innovation Requirement)
7. 情感复杂性 (Emotional Complexity)
```

## 二、复杂度评估算法

### 2.1 智能评估矩阵
```
复杂度计算公式:
Complexity_Score = Σ(Dimension_i × Weight_i × Context_Factor_i)

其中:
- Dimension_i: 各维度评分 (1-10)
- Weight_i: 维度权重
- Context_Factor_i: 上下文调节因子
```

### 2.2 维度评估标准

**认知复杂度评估**:
```
1-2分: 简单事实查询、基础计算
3-4分: 多步骤推理、概念解释
5-6分: 复杂分析、系统性思考
7-8分: 创新问题解决、跨领域整合
9-10分: 哲学思辨、开放性探索
```

**信息密度评估**:
```
1-2分: 单一信息源、明确数据
3-4分: 多个相关信息源
5-6分: 大量信息需要筛选整合
7-8分: 信息冲突需要权衡
9-10分: 信息稀缺需要推理补充
```

**不确定性程度评估**:
```
1-2分: 确定性问题、标准答案
3-4分: 轻微不确定性、可验证
5-6分: 中等不确定性、需要假设
7-8分: 高度不确定性、多种可能
9-10分: 极度不确定性、探索性问题
```

## 三、思考深度分级体系

### 3.1 五级深度模式

**Level 1: 快速响应模式 (Rapid Response)**
- **适用场景**: 简单查询、基础事实、常规操作
- **思考特征**: 系统1主导，直觉性回答
- **时间分配**: 最小化思考时间
- **质量标准**: 准确性优先，效率最大化

```
Level 1 处理流程:
1. 快速模式识别
2. 直接知识检索
3. 基础验证
4. 立即响应
```

**Level 2: 标准分析模式 (Standard Analysis)**
- **适用场景**: 中等复杂度问题、多步骤任务
- **思考特征**: 系统1+2协作，结构化分析
- **时间分配**: 平衡思考深度与效率
- **质量标准**: 准确性与完整性并重

```
Level 2 处理流程:
1. 问题分解
2. 多角度分析
3. 逻辑验证
4. 结构化回答
```

**Level 3: 深度思考模式 (Deep Thinking)**
- **适用场景**: 复杂问题、创新需求、系统性分析
- **思考特征**: 系统2主导，多层次推理
- **时间分配**: 充分的思考时间
- **质量标准**: 深度与洞察力优先

```
Level 3 处理流程:
1. 全面问题分析
2. 多维度探索
3. 创新性思考
4. 深度验证
5. 洞察性回答
```

**Level 4: 探索性思维模式 (Exploratory Thinking)**
- **适用场景**: 开放性问题、哲学思辨、前沿探索
- **思考特征**: 发散-收敛循环，元认知监控
- **时间分配**: 不限制思考时间
- **质量标准**: 原创性与深度并重

```
Level 4 处理流程:
1. 开放性探索
2. 多假设生成
3. 跨领域联想
4. 批判性反思
5. 创新性综合
```

**Level 5: 超深度研究模式 (Ultra-Deep Research)**
- **适用场景**: 极其复杂的研究问题、重大决策支持
- **思考特征**: 全方位认知资源调动
- **时间分配**: 无时间限制的深度思考
- **质量标准**: 最高质量的分析和洞察

```
Level 5 处理流程:
1. 全景式问题映射
2. 多学科整合分析
3. 系统性假设验证
4. 深度元认知反思
5. 突破性洞察生成
```

## 四、动态调节机制

### 4.1 实时调节算法
```
if Complexity_Score <= 20:
    Thinking_Level = 1
elif Complexity_Score <= 40:
    Thinking_Level = 2
elif Complexity_Score <= 60:
    Thinking_Level = 3
elif Complexity_Score <= 80:
    Thinking_Level = 4
else:
    Thinking_Level = 5

# 上下文调节
if Time_Sensitive:
    Thinking_Level = max(1, Thinking_Level - 1)
if High_Stakes:
    Thinking_Level = min(5, Thinking_Level + 1)
```

### 4.2 自适应优化机制

**反馈学习循环**:
```
1. 执行思考过程
2. 评估输出质量
3. 收集用户反馈
4. 调整评估参数
5. 优化调节算法
```

**动态权重调整**:
- 根据历史表现调整维度权重
- 基于用户偏好优化深度选择
- 考虑领域特征调整策略

## 五、特殊情况处理

### 5.1 紧急情况协议
```
紧急情况识别:
- 安全相关问题
- 医疗紧急情况
- 法律风险问题
- 伦理敏感话题

处理策略:
1. 立即升级到Level 4+
2. 激活伦理边界检查
3. 多重验证机制
4. 保守性原则优先
```

### 5.2 创新激发模式
```
创新需求识别:
- 用户明确要求创新
- 问题缺乏标准答案
- 需要突破性思考

激发策略:
1. 强制Level 3+思考
2. 激活发散思维
3. 跨领域类比
4. 反常规思考
```

### 5.3 效率优先模式
```
效率需求识别:
- 用户时间紧迫
- 简单重复性任务
- 明确的标准流程

优化策略:
1. 降级到Level 1-2
2. 模板化响应
3. 快速验证
4. 直接输出
```

## 六、质量保证机制

### 6.1 多层次验证
```
验证层次:
Level 1: 基础事实检查
Level 2: 逻辑一致性验证
Level 3: 深度分析验证
Level 4: 创新性评估
Level 5: 突破性验证
```

### 6.2 自我监控指标
- **准确性指标**: 事实正确率、逻辑一致性
- **完整性指标**: 覆盖度、深度充分性
- **效率指标**: 时间成本、资源利用率
- **创新性指标**: 原创度、洞察价值
- **用户满意度**: 反馈评分、采纳率

## 七、实施指导

### 7.1 集成要求
- 与ai-thinking-protocol.md协同工作
- 支持ai-ethical-boundaries.md的伦理检查
- 配合智能推荐引擎的决策支持

### 7.2 监控与优化
```
持续改进循环:
1. 性能数据收集
2. 模式识别分析
3. 算法参数调优
4. 策略规则更新
5. 效果验证评估
```

---

## 附录A: 评分算法实现细节

### A.1 维度评分计算方法

认知复杂度评分实现:
  def calculate_cognitive_complexity(task):
      score = 0
      
      # 1. 步骤数量 (0-3分)
      steps = count_required_steps(task)
      if steps <= 2:
          score += 1
      elif steps <= 5:
          score += 2
      else:
          score += 3
      
      # 2. 概念抽象度 (0-3分)
      abstraction = measure_abstraction_level(task)
      score += abstraction  # 0:具体, 1:半抽象, 2:抽象, 3:高度抽象
      
      # 3. 领域知识需求 (0-4分)
      domain_knowledge = assess_domain_knowledge(task)
      score += domain_knowledge  # 0:通用, 1:基础, 2:中级, 3:高级, 4:专家
      
      # 归一化到1-10
      return min(10, max(1, score))

信息密度评分实现:
  def calculate_information_density(context):
      score = 0
      
      # 1. 信息源数量
      sources = count_information_sources(context)
      if sources <= 1:
          score += 2
      elif sources <= 3:
          score += 4
      elif sources <= 5:
          score += 6
      else:
          score += 8
      
      # 2. 信息冲突程度
      conflicts = detect_conflicting_information(context)
      score += min(2, conflicts)  # 最多+2分
      
      # 归一化到1-10
      return min(10, max(1, score))

不确定性评分实现:
  def calculate_uncertainty(task, context):
      score = 0
      
      # 1. 明确性程度 (0-4分)
      clarity = assess_requirement_clarity(task)
      score += (4 - clarity)  # 越不明确分数越高
      
      # 2. 可验证性 (0-3分)
      verifiability = check_verifiability(task)
      score += (3 - verifiability)
      
      # 3. 先例数量 (0-3分)
      precedents = count_similar_precedents(task)
      if precedents == 0:
          score += 3
      elif precedents <= 2:
          score += 2
      elif precedents <= 5:
          score += 1
      
      # 归一化到1-10
      return min(10, max(1, score))

### A.2 上下文因子计算

def calculate_context_factor(dimension, context):
    """
    计算上下文调节因子 (0.5-1.5)
    用于微调维度权重
    """
    base_factor = 1.0
    
    if dimension == "cognitive_complexity":
        # 项目熟悉度调节
        if context.project_familiarity == "high":
            base_factor *= 0.8  # 熟悉项目降低复杂度
        elif context.project_familiarity == "low":
            base_factor *= 1.2
        
        # 用户经验调节
        if context.user_experience == "expert":
            base_factor *= 0.9
        elif context.user_experience == "beginner":
            base_factor *= 1.1
    
    elif dimension == "time_sensitivity":
        # 紧急程度调节
        if context.urgency == "critical":
            base_factor *= 1.3
        elif context.urgency == "low":
            base_factor *= 0.7
    
    # 限制在合理范围
    return min(1.5, max(0.5, base_factor))

### A.3 完整评分示例

示例1 - 简单查询:
  任务: "JavaScript的变量声明方式有哪些？"
  
  评分过程:
    认知复杂度: 2/10
      - 单步骤 (+1)
      - 具体概念 (+0)
      - 基础知识 (+1)
    
    信息密度: 2/10
      - 单一信息源 (+2)
      - 无冲突 (+0)
    
    不确定性: 1/10
      - 明确问题 (+0)
      - 可验证 (+0)
      - 常见问题 (+0)
    
    时间敏感性: 3/10 (假设非紧急)
    风险等级: 1/10 (低风险)
    
  计算:
    Score = Σ(Dimension_i × Weight_i × Context_Factor_i)
          = (2×0.25×1.0) + (2×0.20×1.0) + (1×0.20×1.0) + (3×0.15×1.0) + (1×0.10×1.0)
          = 0.5 + 0.4 + 0.2 + 0.45 + 0.1
          = 1.65
    
    归一化: 1.65 × 10 = 16.5
  
  结果: 16.5分 → Level 1 (快速响应模式)

示例2 - 复杂设计:
  任务: "设计一个可扩展的微服务架构来支持百万用户"
  
  评分过程:
    认知复杂度: 9/10
      - 多步骤 (+3)
      - 高度抽象 (+3)
      - 专家知识 (+4) → 10分，取9
    
    信息密度: 7/10
      - 多信息源 (+6)
      - 轻微冲突 (+1)
    
    不确定性: 8/10
      - 要求不够具体 (+3)
      - 难以完全验证 (+2)
      - 少量先例 (+2)
    
    时间敏感性: 6/10 (假设有期限)
    风险等级: 9/10 (高风险)
    创新要求: 8/10
    
  计算:
    Score = (9×0.25×1.2) + (7×0.20×1.0) + (8×0.20×1.1) + (6×0.15×1.0) + (9×0.10×1.3) + (8×0.10×1.0)
          = 2.7 + 1.4 + 1.76 + 0.9 + 1.17 + 0.8
          = 8.73
    
    归一化: 8.73 × 10 = 87.3
  
  结果: 87.3分 → Level 5 (超深度研究模式)

### A.4 实时调节机制

动态权重调整:
  def adjust_weights_based_on_feedback(dimension_weights, feedback_history):
      """
      基于反馈历史调整维度权重
      """
      for dimension in dimension_weights:
          # 获取该维度相关的反馈
          relevant_feedback = filter_feedback(feedback_history, dimension)
          
          # 计算该维度的预测准确率
          accuracy = calculate_prediction_accuracy(relevant_feedback)
          
          # 调整权重
          if accuracy < 0.7:
              # 准确率低，降低权重
              dimension_weights[dimension] *= 0.95
          elif accuracy > 0.9:
              # 准确率高，微调权重
              dimension_weights[dimension] *= 1.02
      
      # 归一化权重总和为1
      normalize_weights(dimension_weights)
      
      return dimension_weights

---

**注意**: 本机制是AI认知能力的核心调节系统，确保在不同情境下都能提供最适合的思考深度和质量。所有AI交互都应根据此机制动态调节思考策略。