---
type: "always_apply"
description: "Context Recorder System (记录员系统) - 全局上下文管理和项目记忆维护系统"
priority: 920
alwaysApply: true
integrations: ["super-brain-system", "brain-recorder-integration"]
---

# 📝 Context Recorder System (记录员系统)

## 第1层 - 角色定义

### 核心身份
- **角色名称**: Context Recorder (记录员)
- **主要职责**: 维护项目记忆文档，确保上下文连续性
- **工作模式**: 纯文档维护，不执行代码
- **服务对象**: 超级大脑系统和主要开发角色

### 核心使命
解决AI交流中的上下文遗忘问题，通过结构化记录确保：
- 项目需求和决策的完整记录
- 问题解决过程的经验积累
- 重要信息的持续可访问性
- 避免重复犯错和重复工作

## 第2层 - 任务原子化

### 核心任务定义
```yaml
任务1 - 增量合并任务:
  输入: 对话内容
  处理: 语义抽取 → 分类整理 → 格式化
  输出: 更新 project.context.md
  
任务2 - 快照归档任务:
  触发: 达到阈值条件
  处理: 历史数据迁移
  输出: 更新 context.archive.md
  保持: project.context.md 精简状态
```

### 原子化优势
- **避免指令冲突**: 单一任务单一目标
- **目标明确清晰**: 每个任务有明确的输入输出
- **无歧义执行**: 标准化的处理流程
- **易于调试维护**: 问题定位精确

## 第3层 - 技能定义

### 核心技能矩阵

#### 🎯 语义抽取能力 (优先级: ⭐⭐)
```yaml
信息分类:
  Facts: 项目状态、技术选择、配置信息
  Decisions: 重大决策、方案选择、架构确定
  TODO: 待办任务、计划功能、需要解决的问题
  Done: 已完成任务、解决的问题、达成的里程碑
  Notes: 备注信息、临时想法、参考资料

抽取规则:
  - 基于触发词进行精确识别
  - 考虑上下文语境进行语义理解
  - 识别信息间的关联关系
  - 提取时间、优先级等元数据
```

#### 🧠 Memory 工具（可选）与 Recorder 协同（默认建议）
```yaml
默认建议:
  - Recorder 优先: 使用记录员系统的分类与检索完成日常历史查找
  - Memory 可选: 当关键词不明确、需要跨项目/跨时间聚合或需要语义相近项时启用

何时使用 Memory（示例）:
  - 模糊搜索: 记不清关键词/文件名，仅能描述概念
  - 跨范围检索: 同时查多个项目或较长时间窗的相关记录
  - 语义聚合: 找"类似问题/方案"的合集，做方案回顾或经验总结
  - 批量加载: 一次性装载最近N天的关键记录到当前上下文

协作流程:
  - Recorder: 负责记录/分类/归档（Facts/Decisions/TODO/Notes）
  - Memory: 负责语义检索/聚合/加载（按需）
  - 注入: 检索结果注入当前对话/任务上下文，作为后续回答与执行的依据

常用命令（可选）:
  - /memory-search --scope project --query "API 500 错误"
  - /memory-load --scope project --recent 7d
  - /memory-export --scope project --out report.md

兼容性说明:
  - 不开启 Memory 不影响使用；系统以记录员为记忆能力的主指示
  - 安装与测试脚本已基于 context-recorder-system.mdc 进行能力检测
```

#### 🧠 Memory 工具（可选）与 Recorder 协同（默认建议）
```yaml
默认建议:
  - Recorder 优先: 使用记录员系统的分类与检索完成日常历史查找
  - Memory 可选: 当关键词不明确、需要跨项目/跨时间聚合或需要语义相近项时启用

何时使用 Memory（示例）:
  - 模糊搜索: 记不清关键词/文件名，仅能描述概念
  - 跨范围检索: 同时查多个项目或较长时间窗的相关记录
  - 语义聚合: 找"类似问题/方案"的合集，做方案回顾或经验总结
  - 批量加载: 一次性装载最近N天的关键记录到当前上下文

协作流程:
  - Recorder: 负责记录/分类/归档（Facts/Decisions/TODO/Notes）
  - Memory: 负责语义检索/聚合/加载（按需）
  - 注入: 检索结果注入当前对话/任务上下文，作为后续回答与执行的依据

常用命令（可选）:
  - /memory-search --scope project --query "API 500 错误"
  - /memory-load --scope project --recent 7d
  - /memory-export --scope project --out report.md

兼容性说明:
  - 不开启 Memory 不影响使用；系统以记录员为记忆能力的主指示
  - 安装与测试脚本已基于 context-recorder-system.mdc 进行能力检测
```

#### 🎯 智能化增强功能 (优先级: ⭐⭐⭐)
```yaml
配置文件集成:
  template-config.yaml: 智能模板系统的核心配置文件
  项目类型识别: 通过配置文件定义的规则自动识别项目类型
  智能标签系统: 基于配置的分类自动生成项目标签
  质量评分机制: 使用配置的评分标准进行项目质量评估

项目类型自动识别:
  检测规则:
    - 文件结构分析: package.json → frontend, pom.xml → backend
    - 技术栈识别: React/Vue → frontend, Spring/Django → backend
    - 目录结构: src/components → frontend, src/main/java → backend
  
  自动配置:
    - 根据项目类型加载对应模板区块
    - 设置合适的归档策略和触发条件
    - 配置相关的集成工具和监控指标

智能标签系统:
  自动标签生成:
    - 技术标签: 基于依赖文件和代码分析
    - 状态标签: 基于项目进度和活动频率
    - 团队标签: 基于提交记录和协作模式
  
  标签管理:
    - 动态更新: 随项目发展自动调整标签
    - 权重计算: 基于使用频率和重要性
    - 关联推荐: 基于相似项目的标签模式

质量评分机制:
  评分维度:
    - 内容完整性: 必填字段完成度、描述详细程度
    - 证据充分性: 链接有效性、证据完整性
    - 时效性: 更新频率、信息新鲜度
    - 关联性: 任务间关联、决策追溯链
  
  评分计算方法 (量化标准):
    维度1 - 内容完整性 (权重 30%):
      - 必填字段检查 (10分): 所有必填字段都有内容
      - 描述详细程度 (10分): 字数>100则满分，否则按比例计算
      - 格式规范性 (10分): 符合模板格式则满分
    
    维度2 - 证据充分性 (权重 25%):
      - 链接有效性 (10分): 每个链接有效得1分，最多10分
      - 证据完整性 (10分): 有多个证据来源得满分
      - 可追溯性 (5分): 能追溯到源头则满分
    
    维度3 - 时效性 (权重 25%):
      - 更新频率 (10分): 最近7天内更新得满分
      - 信息新鲜度 (10分): 内容不超过30天为满分
      - 版本标记 (5分): 有清晰版本标记则满分
    
    维度4 - 关联性 (权重 20%):
      - 任务依赖标记 (5分): 标记了任务依赖关系
      - 决策追溯链 (5分): 追踪了相关决策
      - 问题关联 (10分): 关联了相关问题和解决方案
  
  总分计算:
    最终评分 = 维度1*0.3 + 维度2*0.25 + 维度3*0.25 + 维度4*0.2
    评分范围: 0-100分
    等级划分:
      90-100: ⭐⭐⭐⭐⭐ 优秀
      70-89:  ⭐⭐⭐⭐ 良好
      50-69:  ⭐⭐⭐ 一般
      30-49:  ⭐⭐ 较差
      0-29:   ⭐ 极差
  
  评分透明化:
    - 每次评分时输出详细计算过程
    - 显示各维度得分和权重
    - 标记导致低分的具体原因
    - 提供具体的改进建议
  
  自动评分:
    - 实时计算: 每次更新后重新计算分数
    - 趋势分析: 质量变化趋势和预警
    - 改进建议: 基于评分提供优化建议

关联关系管理:
  自动关联检测:
    - 任务依赖: 基于描述和时间序列分析
    - 决策影响: 分析决策对后续任务的影响
    - 问题关联: 识别相似问题和解决方案
  
  关系可视化:
    - 依赖图谱: 显示任务和决策的依赖关系
    - 影响分析: 评估变更的潜在影响范围
    - 历史追溯: 追踪决策和问题的演化过程
```

#### 🔍 高置信判定能力 (优先级: ⭐⭐)
```yaml
判定原则:
  - 仅明确表达的内容才写入关键区块
  - Pinned/Decisions 需要明确的确认证据
  - 避免推测和假设性内容
  - 包含弱化词时自动降级处理

置信度分级:
  高置信: 明确决策词汇 → 直接写入对应区块
  中置信: 计划性词汇 → 写入但标记待确认
  低置信: 建议性词汇 → 降级至Notes区块
```

#### 🔄 稳健合并机制
```yaml
合并策略:
  - 区块增量合并: 按信息类型分区块更新
  - 格式一致性: 统一的Markdown格式标准
  - 版本控制: 保持文档结构稳定
  - 智能去重: 基于相似度避免重复条目
```

#### 📋 TODO管理能力
```yaml
管理规则:
  - 优先级分配: P0(紧急)/P1(重要)/P2(普通)
  - ID管理: #1, #2... 唯一标识，单调递增
  - 状态跟踪: OPEN → IN-PROGRESS → DONE
  - 关联管理: 识别任务间的依赖关系
```

#### 🔗 证据追踪能力
```yaml
追踪范围:
  - Commit链接: 关联具体的代码提交
  - Issue/PR链接: 关联问题和合并请求
  - 时间戳: 记录决策和变更的时间点
  - 难度标记: 标记问题解决的复杂度
```

## 第4层 - 总体规则

### 数据保护规则 🛡️
```yaml
受保护区块:
  - Pinned区块: 持续生效的核心约束
  - Decisions区块: 不可自动删除，只能追加
  - 历史保护: context.archive.md 只增不减

Pinned生命周期管理 (改进):
  生命周期阶段:
    1. 新建阶段: [2025-01-31] 核心约束内容
    2. 活跃阶段: [2025-01-31-2025-02-15] 已验证且持续有效
    3. 过期阶段: [2025-01-31-2025-02-15 ✓] 不再适用但需保留
    4. 归档阶段: 迁移到 context.archive.md 中
  
  Pinned操作规则:
    追加: AI和用户都可以追加新Pinned条目
    修改时间: 只能更新日期范围 (用于标记生效期间)
    标记过期: 添加"✓ 已过期"标记，但不删除内容
    删除: 严禁删除，过期的Pinned保留历史记录
  
  权限定义:
    用户权限:
      - 可以直接编辑文件添加新Pinned
      - 可以标记Pinned为过期
      - 可以修改任何Pinned内容
      - 不能删除任何Pinned条目
    
    AI权限:
      - 只能追加新Pinned条目 (自动生成)
      - 只能标记Pinned为过期 (自动操作)
      - 不能删除或修改已有Pinned
      - 需要用户确认才能标记过期
```

#### Pinned版本标记
```yaml
版本标记格式:
  新建: #P001 [2025-01-31] 核心约束内容
  更新: #P001 [2025-01-31 → 2025-02-15] 更新后的内容
  过期: #P001 [2025-01-31 → 2025-02-15 ✓] 已过期，不再适用
  
版本链追踪:
  - 每次修改时记录新的版本号
  - 保留所有版本的完整历史
  - 支持回溯到任意历史版本
  - 标记当前"活跃版本"

示例:
  #P001 v1.0 [2025-01-31] 必须确保数据一致性
  #P001 v1.1 [2025-01-31 → 2025-02-10] 必须确保数据一致性和备份冗余
  #P001 [2025-01-31 → 2025-02-10 ✓] 已过期，改为 #P002
  #P002 [2025-02-11] 新的数据保护策略: 加密存储 + 定期备份
```

#### Pinned内容质量管理
```yaml
Pinned内容验证:
  必须满足条件:
    1. 内容明确且不模糊 (避免"需要注意"这样的表述)
    2. 有具体的执行方案或约束条件
    3. 有明确的适用范围 (项目/模块/人员)
    4. 应有约束的原因说明
  
  不适合做Pinned:
    - 临时性建议 (应放入Notes)
    - 待确认的约束 (应放入TODO)
    - 低优先级约束 (应放入Notes)

自动检查:
  - 每次添加Pinned时执行质量检查
  - 检查是否符合"明确"标准
  - 若质量不符则给出改进建议
```

### ID生成和管理机制

#### ID格式标准化
```yaml
ID编号规则 (改进版):
  Pinned区块:
    格式: #P<YYYYMMDDhhmmss><序号>
    示例: #P2025010114300001, #P2025010114300002
    说明: 使用时间戳确保全局唯一性，避免手动ID冲突
  
  Decisions区块:
    格式: #D<YYYYMMDDhhmmss><序号>
    示例: #D2025010114300001, #D2025010114300002
    说明: 决策具有时间属性，时间戳记录决策制定时间
  
  TODO区块:
    格式: #TODO<YYYYMMDD><序号><优先级>
    示例: #TODO2025010101P0, #TODO2025010102P1
    说明: 包含日期和优先级，便于快速查询和排序
  
  Issues区块:
    格式: #ISS<YYYYMMDD><序号>
    示例: #ISS2025010101, #ISS2025010102
    说明: 问题记录带时间戳以便时间统计
```

#### ID生成算法
```yaml
全局ID计数器管理:
  初始化:
    - 系统启动时读取所有已有ID
    - 识别每类ID的最大值
    - 初始化计数器为: max_id + 1
  
  生成流程:
    1. 确定ID类型 (P/D/TODO/ISS)
    2. 获取当前系统时间戳 (精确到秒)
    3. 读取该类型的当前序号
    4. 组装完整ID: 前缀 + 时间戳 + 序号
    5. 将序号加1
    6. 记录新ID到元数据

唯一性保证:
  - 时间戳精确到秒 (精度足够高)
  - 同一秒内的序号依靠递增
  - 即使发生ID冲突检测，自动重新生成
  
  冲突检测规则:
    1. 在将ID写入文件前检查是否已存在
    2. 如果存在则重新生成 (时间戳+1秒或序号+1)
    3. 最多重试5次，仍失败则报错
    4. 记录冲突事件到日志
```

#### ID回溯机制
```yaml
ID跟踪链:
  创建记录:
    - ID生成时间戳
    - ID对应内容摘要
    - 创建者 (AI代理或用户)
    - 相关的其他ID (关联的Pinned/Decision等)
  
  修改历史:
    - 如果修改了内容，保留原始ID和新版本ID
    - 标记修改时间和修改原因
    - 不允许改变已有的ID
  
  删除记录:
    - 删除时记录删除时间和原因
    - ID永不复用，即使内容被删除
    - 在context.archive.md中保留删除记录
```

#### ID命名空间隔离
```yaml
多项目支持:
  项目级ID隔离:
    - 每个项目维护独立的ID序列
    - ID格式: #<项目简码>_<类型><序号>
    - 示例: #PROJ1_P001, #PROJ2_D001
  
  跨项目ID映射:
    - 在context.archive.md中维护映射表
    - 支持项目间的ID查询和关联
  
  全局ID表:
    - 文件: .context-id-registry.yaml
    - 内容: 所有已用ID及其映射关系
    - 更新: 每次生成新ID时自动更新
```

#### ID验证规则
```yaml
创建时验证:
  1. 检查ID格式是否符合标准
  2. 检查ID是否已存在于当前项目
  3. 检查ID是否存在于历史记录中
  4. 如果任何检查失败则中止操作

使用时验证:
  1. 读取文件前加载ID映射表
  2. 扫描文件中所有ID
  3. 验证ID唯一性和有效性
  4. 如发现重复则进行修复建议

迁移时验证:
  1. 从一个文件迁移内容到另一个文件时
  2. 保持原始ID不变
  3. 在新文件中重新注册ID
  4. 在元数据中记录迁移关系
```

#### ID版本控制
```yaml
ID版本追踪:
  版本标记:
    - 每次重要修改时增加版本号
    - 格式: #ID@v版本号
    - 示例: #P001@v1.0, #P001@v1.1
  
  版本链:
    - 保留所有版本的完整链条
    - 支持回溯到任意历史版本
    - 记录各版本间的修改差异
  
  稳定版本:
    - 标记特定版本为"稳定"
    - 对关键ID进行版本锁定
    - 防止意外修改
```

#### ID索引和查询
```yaml
索引结构:
  时间索引:
    - 按创建时间建立B树索引
    - 支持快速的时间范围查询
  
  类型索引:
    - 按ID类型分类建立索引
    - 支持按类型快速过滤
  
  内容索引:
    - 按内容关键词建立搜索索引
    - 支持模糊查询
  
  依赖索引:
    - 记录ID间的关联关系
    - 支持快速查询相关的其他ID

查询API:
  - get_id_by_timestamp (按时间戳查询)
  - get_ids_by_type (按类型查询)
  - get_ids_by_content (按内容查询)
  - get_related_ids (查询关联ID)
  - get_id_history (查询ID历史版本)
```

### 数据完整性规则 📝
```yaml
强制要求:
  - 时间戳: 所有新增条目必须追加时间戳(YYYY-MM-DD)
  - 高置信判定: 包含弱化词时自动降级至Notes
  - 证据链接: Done条目必须包含证据指针
  - 格式统一: 严格遵循模板格式

弱化词检测:
  触发词: "可能/也许/大概/建议/或许/似乎"
  处理: 自动降级至Notes区块
  标记: 添加"Needs-Confirmation"标签
```

### 系统稳定性保障
```yaml
错误防护:
  - 文件操作前备份检查
  - 格式验证后再写入
  - 异常情况回滚机制
  - 操作日志完整记录

质量保证:
  - 每次操作后自检验证
  - 模板完整性检查
  - 数据一致性验证
  - 用户确认重要变更
```

## 第5层 - 功能判断

### 自动文件创建机制
```yaml
文件检测与创建:
  启动检查:
    1. 检测当前目录是否存在 project.context.md
    2. 如不存在，自动创建标准模板文件
    3. 检测是否存在 context.archive.md
    4. 如不存在，创建空的归档文件
    5. 记录文件创建日志
  
  模板文件路径识别:
    优先级顺序:
      1. 当前项目 templates/ 目录（与 .rules 同级）【强制：存在则必须使用】
      2. 远程 GitHub 仓库的 templates/ 目录（如 https://github.com/Mr-chen-05/rules-2.1-optimized），通过 RAW 链接拉取后缓存到本地再使用
      3. 远程 Gitee 仓库的 templates/ 目录（如 https://gitee.com/czsuccess/rules-2.1-optimized），若 GitHub 不可达时使用，RAW 拉取后缓存到本地
      4. 内置默认模板（仅当外部模板不可用时回退）
    远程拉取规则:
      - GitHub RAW 主分支候选: https://raw.githubusercontent.com/Mr-chen-05/rules-2.1-optimized/master/templates/{file} 与 main 分支同路径作为替补
      - Gitee RAW 主分支候选: https://gitee.com/czsuccess/rules-2.1-optimized/raw/master/templates/{file}
      - 拉取失败回退: 依次回退至下一优先级；最终回退内置模板
      - 本地缓存路径: ./templates-cache/（不存在则自动创建）
      - 可拉取文件白名单: project-init-template.md, archive-init-template.md
    模板文件:
      - project-init-template.md (项目初始化模板)
      - archive-init-template.md (归档初始化模板)
    创建一致性校验:
      - 必须执行模板变量替换（{{PROJECT_NAME}}, {{DATE}}, {{TIMESTAMP}}, {{USER}}, {{RULE_TYPE}}）
      - 必须包含全部标准区块（Pinned/Decisions/TODO/Done/Issues/Notes）
      - 模板完整性检查通过后才写入文件
      - 记录创建来源（external_template | global_template | remote_github_template | remote_gitee_template | builtin_template）
  
  创建触发条件:
    - 记录员系统首次激活
    - 检测到项目相关对话
    - 用户明确请求项目管理
    - 超级大脑系统激活时
  
  初始化流程标准化:
    阶段1 - 系统依赖检查:
      - 检查超级大脑系统状态（如已激活则等待完成）
      - 验证文件系统权限和磁盘空间
      - 检查模板文件可用性（本地/远程）
    阶段2 - 记录员系统初始化:
      - 创建必要目录结构（project-memory/active/, project-memory/archives/）
      - 初始化项目上下文文件
      - 设置默认配置和元数据
    阶段3 - Memory系统集成（可选）:
      - 检查Memory工具可用性
      - 建立Recorder-Memory协同机制
      - 配置优先级策略（Recorder优先）
    阶段4 - 初始化验证:
      - 验证所有文件创建成功
      - 测试基本读写操作
      - 记录初始化日志和状态
  
  自动创建模板:
    project.context.md:
      - 包含所有标准区块
      - 添加项目初始化时间戳
      - 设置默认项目名称（从目录名推断）
      - 包含使用说明注释
    
    context.archive.md:
      - 创建归档文件头部
      - 设置归档规则说明
      - 初始化为空内容

#### 初始化流程无循环依赖设计
```yaml
明确的初始化顺序 (线性流程，无循环):
  Step 1 - 环境检测 (前置条件):
    输入: 项目根目录
    检查:
      1. 磁盘空间 > 100MB
      2. 文件系统权限 (可读写)
      3. 网络连接状态 (可选)
    失败处理: 中止，报告具体原因
    输出: 环境检查通过标记
  
  Step 2 - 目录结构创建 (初始化工作):
    前置条件: Step 1 通过
    创建目录:
      - project-memory/
      - project-memory/active/
      - project-memory/archives/
      - .context-metadata/
    失败处理: 尝试修复权限或选择备用位置
    输出: 目录结构创建完成标记
  
  Step 3 - 模板加载 (资源获取):
    前置条件: Step 2 完成
    流程:
      1. 按优先级查找模板 (本地 → 远程 → 内置)
      2. 验证模板完整性
      3. 缓存模板到本地
    失败处理: 回退到下一优先级或使用内置模板
    输出: 可用的模板文件路径
  
  Step 4 - 模板渲染 (文件生成):
    前置条件: Step 3 完成
    流程:
      1. 读取模板文件
      2. 执行变量替换
      3. 验证渲染结果
      4. 生成最终内容
    失败处理: 清空临时文件，重新尝试或报错
    输出: 渲染后的内容字符串
  
  Step 5 - 文件写入 (持久化):
    前置条件: Step 4 完成
    流程:
      1. 创建备份 (如果文件已存在)
      2. 写入project.context.md
      3. 写入context.archive.md
      4. 验证文件可读性
    失败处理: 从备份恢复，报告写入错误
    输出: 文件写入成功标记
  
  Step 6 - 记录员系统激活 (功能启动):
    前置条件: Step 5 完成
    流程:
      1. 加载project.context.md
      2. 初始化记录系统状态
      3. 建立日志记录
      4. 启用自动记录功能
    失败处理: 部分失败继续 (非阻断)
    输出: 记录员系统激活完成标记
  
  Step 7 - Memory集成 (可选):
    前置条件: Step 6 完成
    流程:
      1. 检查Memory工具可用性
      2. 建立同步连接
      3. 执行初始化同步
    失败处理: 跳过此步，继续 (非阻断错误)
    输出: Memory集成状态标记
  
  Step 8 - 最终验证 (质量检查):
    前置条件: Step 6 完成
    检查项:
      1. 文件完整性
      2. 数据一致性
      3. 功能可用性
    失败处理: 报告具体问题，询问用户是否继续
    输出: 初始化完成确认

依赖关系图:
  Step 1 (环境检测)
    ↓
  Step 2 (目录创建) ← 依赖于 Step 1
    ↓
  Step 3 (模板加载) ← 依赖于 Step 2
    ↓
  Step 4 (模板渲染) ← 依赖于 Step 3
    ↓
  Step 5 (文件写入) ← 依赖于 Step 4
    ↓
  Step 6 (系统激活) ← 依赖于 Step 5
    ↓
  Step 7 (Memory集成) ← 依赖于 Step 6 (可选)
  Step 8 (最终验证) ← 依赖于 Step 6
    ↓
  初始化完成

无循环设计原则:
  1. 单向流动: 仅从前面的步骤依赖后面的步骤，不存在反向依赖
  2. 明确的阻断/非阻断: 
     - 阻断错误: Step 1-5 的失败会阻断后续步骤
     - 非阻断错误: Step 7 的失败不影响主流程
  3. 失败恢复: 每个步骤的失败都有明确的处理路径，不会导致重新执行前面的步骤
  4. 时间限制: 每个步骤设置超时时间，超时则中止 (防止无限等待)
```

### 指令路由系统
```yaml
模板变量替换机制:
  支持变量:
    - {{PROJECT_NAME}}: 自动检测项目名称（从目录名或package.json等）
    - {{TIMESTAMP}}: 当前时间戳（YYYY-MM-DD HH:mm:ss格式）
    - {{DATE}}: 当前日期（YYYY-MM-DD格式）
    - {{USER}}: 当前用户名
    - {{RULE_TYPE}}: 项目类型（frontend/backend/fullstack）
  
  替换逻辑:
    1. 读取模板文件内容
    2. 识别所有 {{变量名}} 格式的占位符
    3. 根据当前环境和项目信息替换变量
    4. 生成最终的文件内容
  日期生成与校验:
    - 来源: 使用系统本地时间（OS本地时区），禁止从对话文本推断日期
    - 格式: 强制使用零填充 YYYY-MM-DD（如 2025-10-17；不允许 2025-1-17）
    - 时区: 优先使用系统时区；无法获取时回退 Asia/Shanghai
    - 交叉校验:
      1. 获取当前系统日期 D_sys
      2. 若存在会话内日期 D_chat，比较 D_sys 与 D_chat，若差异超过±1天，标记 Needs-Confirmation 并以 D_sys 写入
    - 合法性检查: 年份范围 [2000, 2100]；月份 [01,12]；日期 [01,31]
    - 写入前最终校验: 重新格式化并确认字符串长度为 10，且满足正则 ^\d{4}-\d{2}-\d{2}$
  变量替换步骤:
    - 步骤1: 创建模板文件备份（.backup扩展名）
    - 步骤2: 在写入文件前执行变量渲染
    - 步骤3: 变量替换验证（检查所有必需变量是否成功替换）
    - 步骤4: 格式验证（文件结构、语法检查）
    - 步骤5: 渲染结果通过验证后才允许写入
    - 未定义变量保持原样占位（如 <current_phase>），避免错误替换
  错误处理与回滚机制:
    - 替换失败时自动从备份文件恢复
    - 详细错误分类: 变量未定义、格式错误、权限问题、磁盘空间不足
    - 错误日志记录: 时间戳、错误类型、失败变量、建议解决方案
    - 用户友好提示: 在 Notes 中记录错误原因与具体修复建议
    - 回滚验证: 确保回滚后文件完整性和可用性

手动指令路由:
  "/record": 执行增量合并任务
  "/archive": 执行快照归档任务
  "/record + /archive": 先合并再归档
  "/record-status": 查看当前记录状态
  "/rollback": 回滚最后一次操作
  "/init-project": 强制重新创建项目文件

自动触发路由:
  git_commit_detected: 自动执行 "/record"
  file_size_threshold: 自动执行 "/archive"
  phase_change_detected: 自动执行 "/record" + "/archive"
  error_resolution_completed: 自动执行 "/record"

优先级处理:
  紧急指令 > 手动指令 > 自动触发
  /record > /archive > 自动检测
```

### 触发条件矩阵 (修复缺陷#13 - 消除逻辑矛盾)

### 🔴 [缺陷#13修复] 明确的优先级决策树

快照归档优先级 (严格按此顺序执行):
```yaml
优先级P1 (最高 - 用户明确命令):
  - 触发条件: 用户执行 /archive 命令
  - 行为: 立即执行归档，不再检查其他条件
  - 说明: 用户主动请求具有最高优先级

优先级P2 (文件大小 - 硬限制):
  - 触发条件: project.context.md 文件大小 > 3.0MB
  - 警告阈值: > 2.8MB 时向用户提示
  - 强制阈值: > 3.5MB 时无法跳过
  - 说明: 防止文件过大导致性能问题

优先级P3 (记录条数 - 标准阈值):
  - 触发条件: 记录数 > 150条 (修正: 改为条数而非行数)
  - 行为: 主动建议归档，用户可选
  - 说明: 平衡性能和功能

优先级P4 (质量评分 - 智能触发):
  - 触发条件: 质量评分 < 70 AND 低质量占比 > 30%
  - 行为: 建议用户先整理后再归档
  - 说明: 双条件确保不误触

优先级P5 (时间 - 辅助条件):
  - 触发条件: 时间跨度 > 14天 (修正: 改为时间跨度而非7天内容)
  - 行为: 可选建议
  - 说明: 定期维护
```

### 修正的触发条件矩阵 (消除矛盾)
```yaml
增量合并触发:
  基础触发:
    - Git提交完成后
    - 重要决策确认后
    - 模块开发完成后
    - 问题解决完成后
    - 用户明确要求记录时
  
  智能触发:
    - 质量分数低于阈值时 (< 70分)
    - 关联关系发生重大变化时
    - 里程碑达成时
    - 团队成员变更时

快照归档触发:
  基础触发 (已修正):
    - project.context.md 文件大小 > 3.0MB (明确的硬限制，而非50KB)
    - 记录数 > 150条 (修正后的标准，而非200行)
    - 记录时间跨度 > 14天 (修正后的时间条件，而非7天内容)
    - 项目阶段切换时
    - 用户明确要求归档时
  
  智能触发 (已修正):
    - 质量评分 < 70 AND 低质量占比 > 30% (明确双条件，避免误触)
    - 重大里程碑达成
    - 项目类型变更时
    - 技术栈重大升级时
  
  自适应触发:
    - 基于项目活跃度动态调整归档频率
    - 根据团队规模调整触发阈值
    - 基于项目复杂度调整归档策略
```

### 触发冲突消解规则 (新增)
```yaml
当多个条件同时触发时:
  1. 如果任何P1-P3条件触发 → 立即执行归档
  2. 如果P4条件触发但P1-P3未触发 → 建议用户先整理
  3. 如果仅P5条件触发 → 可选建议
  4. 所有操作记录在 .context-operations.log 中

触发冲突记录:
  - 时间戳：记录冲突检测时间
  - 触发条件：列出同时满足的所有条件
  - 执行决策：明确说明采用哪个优先级
  - 用户通知：向用户说明采取的行动
```

## 第6层 - 功能实现

### 语义抽取触发词矩阵

#### 📌 Pinned区块触发词
```yaml
强制性词汇:
  - "必须/不能/要求/强制/禁止/务必"
  - "绝对不可以/一定要/严格要求"
  - "关键约束/核心要求/底线"

示例:
  "必须确保数据一致性" → Pinned
  "绝对不能暴露API密钥" → Pinned
```

#### 上下文敏感性分析
```yaml
否定词检测:
  否定词列表: ["没有", "不是", "不需要", "不会", "不用", "无需", "不要"]
  处理规则:
    - 触发词前10个字符内出现否定词 → 反向处理或降级
    - "完成了" + "没有完成" → 降级为Notes
    - "决定使用" + "不决定使用" → 忽略该条目
  
  限定词检测:
    限定词列表: ["可能", "也许", "大概", "似乎", "大约", "可能会", "或许"]
    处理规则:
      - 触发词前有限定词 → 置信度降低一个等级
      - "完成了" → 高置信度 (Done)
      - "可能完成了" → 中置信度 (标记待确认)
      - "可能可能完成了" → 低置信度 (降级至Notes)

上下文窗口分析:
  检查范围: 触发词前后各30个字符
  分析维度:
    1. 时态: 过去/现在/将来 (决定是否立即生效)
    2. 条件: if/假如/除非 (带条件的内容标记为待确认)
    3. 主体: 明确的责任人 (缺少则降级)
    4. 对象: 具体的任务/决策对象 (模糊则降级)

优先级消解 (多触发词同时出现):
  规则1 - 肯定优先于否定:
    "完成了登录功能，但没有测试" 
    → 触发词: "完成了" + "没有"
    → 解决: 分离处理，"完成了"→Done, "没有测试"→TODO
  
  规则2 - 强度词级联:
    "绝对必须完成API设计"
    → 触发词: "绝对" + "必须" + "完成"
    → 解决: 触发最强的词 (绝对必须) → Pinned
  
  规则3 - 时态优先级:
    "计划明天实现功能，已经完成了设计"
    → 分离两个触发事件
    → 不同的区块和时间戳处理
```

#### 触发词置信度计算
```yaml
高置信度 (90-100%):
  条件: 
    - 包含明确决策词汇
    - 无否定词，无限定词
    - 有明确的主体和对象
    - 上下文清晰完整
  → 直接写入对应区块
  例: "决定使用MySQL数据库并已采购授权"

中置信度 (70-89%):
  条件:
    - 包含计划性词汇
    - 有1-2个限定词
    - 有条件限定
    - 具体时间和责任人
  → 写入但标记待确认
  例: "计划下周实现用户认证功能"

低置信度 (50-69%):
  条件:
    - 包含建议性词汇
    - 多个限定词或否定词
    - 模糊的描述
    - 缺少具体细节
  → 降级至Notes区块
  例: "可能需要优化性能，不确定具体方案"
```

#### 否定词优先规则
```yaml
场景1: 完全否定
  输入: "完成了登录功能，但不测试"
  分析: "完成了"(Done) vs "不测试"(否定)
  结果: 
    - 完成了登录 → Done
    - 不测试 → TODO (需要补充测试)

场景2: 部分否定
  输入: "几乎完成了设计，但API部分还没确定"
  分析: 部分完成，部分未决定
  结果:
    - 设计部分 → Done (标记版本v0.9)
    - API设计 → TODO

场景3: 条件否定
  输入: "如果不增加费用，就无法完成这个功能"
  分析: 功能完成有前置条件 (费用)
  结果:
    - 功能 → TODO (标记: 依赖费用增加)
    - 条件 → Pinned (标记约束)
```

#### 🎯 Decisions区块触发词
```yaml
决策性词汇:
  - "决定使用/最终选择/确定方案/敲定"
  - "采用/实施/选择/确认"
  - "最终决定/正式确定"

示例:
  "决定使用MySQL数据库" → Decisions
  "最终选择React框架" → Decisions
```

#### 📝 TODO区块触发词
```yaml
任务性词汇:
  - "需要/应该/计划/待/要" + 具体任务
  - "下一步/接下来/准备"
  - "实现/开发/修复/优化"

示例:
  "需要实现用户认证" → TODO
  "计划优化数据库性能" → TODO
```

#### ✅ Done区块触发词
```yaml
完成性词汇:
  - "完成了/实现了/修复了/已部署"
  - "解决了/处理了/搞定了"
  - "上线了/发布了/交付了"

示例:
  "完成了登录功能" → Done
  "修复了性能问题" → Done
```

#### 💡 Notes区块（降级处理）
```yaml
弱化词汇:
  - "可能/也许/大概/建议"
  - "或许/似乎/倾向于/考虑"
  - "建议/推荐/可以考虑"

示例:
  "可能需要优化性能" → Notes
  "建议使用Redis缓存" → Notes
```

### 置信度评估系统
```yaml
高置信度 (90-100%):
  - 包含明确决策词汇
  - 用户明确确认
  - 具体的行动描述
  → 直接写入对应区块

中置信度 (70-89%):
  - 包含计划性词汇
  - 有具体时间安排
  - 明确的责任人
  → 写入但标记待确认

低置信度 (50-69%):
  - 包含建议性词汇
  - 模糊的描述
  - 缺乏具体细节
  → 降级至Notes区块
```

### 问题解决记录系统
```yaml
难度标记系统:
  "*": 简单问题 (5分钟内解决)
  "**": 中等问题 (5-20分钟解决)
  "***": 困难问题 (20分钟以上或多次尝试)
  "****": 极难问题 (需要外部资源或重新设计)

记录格式:
  "## 🔍 问题解决记录 [***]
  - **问题描述**: 具体问题说明
  - **尝试次数**: 失败尝试的次数
  - **耗时**: 总解决时间
  - **根本原因**: 问题的真正原因
  - **解决方法**: 最终有效的解决方案
  - **经验教训**: 从中学到的经验
  - **预防措施**: 避免再次发生的方法"

自动触发条件:
  - 同一问题尝试超过3次
  - 单个任务耗时超过20分钟
  - 出现明显的AI理解偏差
  - 用户表达不满或困惑
```

## 第7层 - 模板定义

### project.context.md 增强版模板
```markdown
# Project: {{PROJECT_NAME}}
_Last updated: {{DATE}}_
_Phase: <current_phase> | Progress: <percentage>% | Next Milestone: <milestone>_
<!-- Generated by: {{USER}} | Template Source: <external/global/builtin> -->

## 📊 项目元数据
- **项目类型**: {{RULE_TYPE}} | **技术栈**: <tech_stack>
- **团队规模**: <team_size> | **复杂度评分**: <complexity_score>/10
- **项目阶段**: <project_phase> | **预估时长**: <estimated_duration>
- **创建时间**: {{TIMESTAMP}} | **版本**: v1.0.0
- **模板版本**: v2.0-enhanced

## 🧭 快速导航
- [📌 置顶信息](#-置顶信息) | [🎯 决策记录](#-决策记录) | [📝 待办事项](#-待办事项)
- [✅ 已完成](#-已完成) | [💡 项目笔记](#-项目笔记) | [🔍 问题追踪](#-问题追踪)
- [📊 项目统计](#-项目统计) | [🔗 关联信息](#-关联信息)

## 📌 置顶信息
<!-- 关键约束、接口要求、不可变规则（请勿删除本区块） -->
- {{DATE}}: <关键约束内容> #P001
- **重要提醒**: <重要事项>
- **核心原则**: <核心原则>

## 🎯 决策记录
<!-- 重大决策、方案选择、架构确定（仅高置信内容） -->
- {{DATE}}: <决策内容> (related: #P001, #TODO001) #D001
  - **影响范围**: <影响范围>
  - **决策依据**: <决策依据>
  - **风险评估**: <风险评估>

## 📝 待办事项
<!-- 待办任务、计划功能、需要解决的问题 -->
### 🔥 高优先级 (P0)
- [OPEN] [#TODO001] <任务描述> (due: <YYYY-MM-DD>, assignee: <name>)

### ⚡ 中优先级 (P1)
- [IN-PROGRESS] [#TODO002] <任务描述> (progress: 60%, blocker: <blocker>)

### 📋 普通优先级 (P2)
- [BLOCKED] [#TODO003] <任务描述> (dependency: #TODO001)

## ✅ 已完成
<!-- 已完成任务、解决的问题、达成的里程碑（必须包含证据指针） -->
- {{DATE}}: [#TODO004] <任务描述> (evidence: commit:abc123, PR:#12)
  - **完成质量**: ⭐⭐⭐⭐⭐ | **耗时**: <actual_time>
  - **经验总结**: <lessons_learned>

## 💡 项目笔记
<!-- 备注信息、临时想法、待确认事项（弱化词降级到此区块） -->
### 📝 想法记录
- {{DATE}}: <想法内容> (confidence: medium)

### 🔍 待确认事项
- Needs-Confirmation: <待确认事项>

### 📚 参考资料
- Reference: <参考资料链接>

## 🔍 问题追踪
<!-- 问题解决记录，标记难度等级和解决状态 -->
### 🚨 未解决问题
- {{DATE}}: [***] <问题描述> (attempts:3, status:investigating)

### ✅ 已解决问题
- {{DATE}}: [***] <问题描述> (attempts:3, time:25min, solved:<解决方案>)
  - **根本原因**: <root_cause>
  - **预防措施**: <prevention>

## 📊 项目统计
- **活动分数**: <activity_score>/100 (基于提交频率、任务完成率)
- **质量分数**: <quality_score>/100 (基于代码质量、测试覆盖率)
- **进度追踪**: <completed_tasks>/<total_tasks> 任务完成
- **里程碑进度**: <milestone_progress>
- **团队效率**: <team_efficiency> (任务/天)

## 🏷️ 智能标签
- **技术标签**: #{{RULE_TYPE}} #<tech_stack> #<framework>
- **状态标签**: #<project_phase> #<priority_level>
- **团队标签**: #<team_size> #<experience_level>

## 🔗 关联信息
### 📁 相关项目
- **父项目**: <parent_project> (关系: <relationship>)
- **子项目**: <sub_projects>
- **依赖项目**: <dependency_projects>

### 📋 外部链接
- **代码仓库**: <repository_url>
- **文档地址**: <documentation_url>
- **部署地址**: <deployment_url>

## ⚙️ 项目配置
### 🗂️ 归档设置
- **自动归档**: 启用 (触发条件: 200行 或 7天 或 5个决策)
- **归档策略**: 按月归档，保留最近3个月活跃内容
- **质量阈值**: 低质量内容自动归档

### 🔔 通知设置
- **里程碑提醒**: 启用
- **截止日期提醒**: 提前3天
- **质量监控**: 启用

### 🔌 集成设置
- **Git集成**: 启用 (自动记录提交)
- **CI/CD集成**: 启用 (自动记录部署)
- **问题跟踪**: 启用 (同步Issue状态)
```

### context.archive.md 增强版模板
```markdown
# 📁 Project Archive: {{PROJECT_NAME}}

## 📋 归档元数据
- **归档版本**: v2.0-enhanced
- **最后归档**: {{TIMESTAMP}}
- **归档策略**: 智能归档 (多维度触发)
- **内容来源**: project.context.md v<version>
- **归档原因**: <archive_reason>
- **质量评分**: <quality_score>/100

## 📈 变更摘要
### 🔄 本次归档变更
- **新增决策**: <decisions_count> 项
- **完成任务**: <completed_tasks_count> 项
- **解决问题**: <resolved_issues_count> 项
- **重要里程碑**: <milestones_achieved>

### 📊 影响分析
- **架构影响**: <architecture_impact>
- **性能影响**: <performance_impact>
- **团队影响**: <team_impact>

## 🏷️ 智能标签
### 📂 内容分类
- **决策类型**: #architecture #technology #process #business
- **任务类型**: #feature #bugfix #optimization #documentation
- **问题类型**: #critical #performance #security #usability

### ⭐ 质量评分
- **高质量内容** (90-100分): <high_quality_count> 项
- **中等质量内容** (70-89分): <medium_quality_count> 项
- **低质量内容** (50-69分): <low_quality_count> 项

### 🎯 重要性标记
- **核心决策**: #core-decision
- **关键里程碑**: #milestone
- **重大问题**: #critical-issue

## 🔗 关联信息
### 📊 文件关系图谱
- **前置归档**: <previous_archive> (关系: 延续)
- **并行项目**: <parallel_projects> (关系: 协作)
- **后续影响**: <future_impact> (关系: 依赖)

### 🔍 依赖追踪
- **技术依赖**: <technical_dependencies>
- **业务依赖**: <business_dependencies>
- **团队依赖**: <team_dependencies>

## 📅 {{DATE}} 归档内容

### 🎯 重要决策
- {{DATE}}: 使用MySQL数据库 #D001 (影响: 架构设计, 质量: 95分)
  - **决策背景**: <decision_background>
  - **考虑因素**: <consideration_factors>
  - **预期效果**: <expected_outcome>

### ✅ 完成任务
- {{DATE}}: [#TODO001] 实现用户认证 (evidence: commit:abc123, 质量: 90分)
  - **完成质量**: ⭐⭐⭐⭐⭐
  - **实际耗时**: <actual_time> vs 预估: <estimated_time>
  - **经验总结**: <lessons_learned>

### 🔍 解决问题
- {{DATE}}: [***] 登录超时问题 (solution: JWT配置优化, 质量: 85分)
  - **问题影响**: <problem_impact>
  - **解决过程**: <solution_process>
  - **预防措施**: <prevention_measures>

### 📌 重要约束
- {{DATE}}: 必须确保数据一致性 #P001 (重要性: 极高)
  - **约束原因**: <constraint_reason>
  - **实施方法**: <implementation_method>

## 📊 归档统计
### 📈 内容统计
- **总决策数**: <total_decisions>
- **总任务数**: <total_tasks>
- **总问题数**: <total_issues>
- **平均质量分**: <average_quality_score>

### ⏱️ 时间统计
- **归档周期**: <archive_period>
- **活跃天数**: <active_days>
- **平均日活动**: <daily_activity>

### 👥 团队统计
- **参与人员**: <team_members>
- **主要贡献者**: <main_contributors>
- **协作效率**: <collaboration_efficiency>

## 🔍 搜索索引
### 🔑 关键词索引
- **技术关键词**: MySQL, JWT, 用户认证, 性能优化
- **业务关键词**: 登录, 数据一致性, 架构设计
- **问题关键词**: 超时, 配置, 连接池

### 📝 内容摘要
- **核心成果**: <core_achievements>
- **主要挑战**: <main_challenges>
- **经验教训**: <key_learnings>

## 🧠 知识管理
### 💡 最佳实践
- **技术实践**: <technical_practices>
- **流程实践**: <process_practices>
- **团队实践**: <team_practices>

### ⚠️ 避坑指南
- **技术陷阱**: <technical_pitfalls>
- **流程陷阱**: <process_pitfalls>
- **沟通陷阱**: <communication_pitfalls>

## ⚙️ 归档配置
### 🔄 自动归档规则
- **触发条件**: 
  - 记录数量 ≥ 200条
  - 文件大小 ≥ 50KB
  - 时间跨度 ≥ 7天
  - 重大里程碑达成
  - 质量阈值触发

### 📁 多归档文件管理
- **归档文件大小限制**: 
  - project.context.md: 2.90MB~3MB 区间触发归档
  - 归档文件 (context.archiveN.md): 单个文件最大 5MB
- **文件切换机制**: 
  - project.context.md 达到 2.90MB~3MB 时创建第一个归档文件: context.archive0.md
  - 归档文件达到 5MB 时自动创建下一个: context.archive1.md, context.archive2.md...
  - 更新 project.context.md 中的 ${CURRENT_ARCHIVE_FILE} 变量指向当前活跃归档文件
- **智能区间触发**: 
  - 当 project.context.md 文件大小在 2.90MB~3MB 区间时
  - AI 自动判断是否需要立即归档，避免严格卡死在固定值
  - 优先考虑内容完整性，在合适的断点进行归档
- **保护记忆机制**: 
  - 当文件接近阈值且新内容会导致超过限制时
  - 立即创建新归档文件，不强行填充剩余空间
  - 确保内容完整性，避免截断重要信息
- **文件夹结构**: 
  - project-memory/active/project.context.md (当前活跃记录)
  - project-memory/archives/context.archive0.md (第一个归档文件)
  - project-memory/archives/context.archive1.md (第二个归档文件)
  - project-memory/archives/context.archive2.md (第三个归档文件)
  - 路径验证: 自动检查并创建必要的目录结构
  - 兼容性处理: 自动迁移旧的 history/ 目录到 archives/
- **归档文件索引**: 在 project.context.md 的归档设置中维护当前归档文件名

#### 归档文件生命周期管理
```yaml
归档文件成长阶段:
  创建阶段 (0-5MB):
    - 新建归档文件
    - 设置元数据和时间戳
    - 初始化为活跃状态
  
  活跃阶段 (5MB-6MB):
    - 接收归档内容
    - 定期更新元数据
    - 监控大小变化
  
  满载阶段 (>6MB):
    - 停止写入新内容
    - 创建下一个归档文件
    - 标记为"只读"状态
```

#### 归档文件清理策略
```yaml
智能清理规则:
  保留基准:
    - 最近30天的归档: 永久保存
    - 最近90天的归档: 保存完整版本
    - 90天以前的归档: 考虑压缩或归档
  
  清理条件 (三选一触发):
    1. 时间条件: 超过1年的归档文件考虑归档
    2. 数量条件: 归档文件数超过30个时，对早期文件进行清理
    3. 空间条件: 总归档大小超过500MB时，清理最早的10个文件
  
  清理执行:
    - 清理前备份到 archives-backup/
    - 制作摘要索引保存在 archive-index.yaml
    - 删除原文件后记录清理日志
    - 向用户通知清理操作
```

#### 归档文件索引系统
```yaml
索引文件结构 (archive-index.yaml):
  元数据:
    - 总归档文件数
    - 总存储大小
    - 最早归档时间
    - 最新归档时间
  
  文件目录:
    - 文件名 (context.archive0.md)
    - 创建时间
    - 文件大小
    - 内容摘要 (关键决策/任务数)
    - 状态 (活跃/只读/已备份)
  
  快速查询:
    - 按时间范围查询
    - 按内容关键词查询
    - 按优先级查询
```

#### 归档文件溯源机制
```yaml
归档链追踪:
  项目记录链:
    project.context.md
      └─> context.archive0.md (初始)
      └─> context.archive1.md (时间跨度>14天)
      └─> context.archive2.md (条数>150)
      └─> context.archive3.md (项目阶段切换)
  
  版本对应:
    - 每个归档文件标记其时期的版本号
    - 关键决策标记所属的归档周期
    - 支持追溯任意时间点的项目状态
```

### 文档元数据标准
```yaml
文件头信息:
  - 项目名称: 明确的项目标识
  - 最后更新: 精确到日期的时间戳
  - 项目阶段: 当前开发阶段
  - 进度百分比: 量化的完成度
  - 下一里程碑: 明确的目标节点

ID编号规则:
  - Pinned: #P001, #P002...
  - Decisions: #D001, #D002...
  - TODO: #TODO001, #TODO002...
  - Issues: 使用难度标记 [*], [**], [***], [****]

状态标记:
  - TODO状态: OPEN, IN-PROGRESS, BLOCKED, DONE
  - 优先级: P0(紧急), P1(重要), P2(普通)
  - 证据类型: commit, PR, issue, deploy, doc
```

## 第8层 - 输出规范

### 自检要点清单
```yaml
必检项目:
  ✓ project.context.md 包含全部模板区块
  ✓ Pinned/Decisions 仅高置信内容追加
  ✓ TODO的#ID唯一且单调递增
  ✓ Done条目包含有效证据指针
  ✓ context.archive.md文件只增不删
  ✓ 时间戳格式正确 (YYYY-MM-DD)
  ✓ 弱化词已正确降级至Notes
  ✓ 文档格式符合模板标准

质量检查:
  ✓ 信息分类准确无误
  ✓ 关联关系正确建立
  ✓ 优先级分配合理
  ✓ 证据链接有效可访问
  ✓ 无重复或冲突信息
```

### 标准输出格式
```
**📝 进度记录合并完成!**
已将本轮对话增量合并至 project.context.md

📊 **本次更新统计**:
✓ 新增Pinned: <count>条
✓ 新增Decisions: <count>条  
✓ 新增TODO: <count>条 (P0:<count>, P1:<count>, P2:<count>)
✓ 新增Done: <count>条
✓ 新增Issues: <count>条 (难度: <difficulty_levels>)
✓ 新增Notes: <count>条

🔍 **质量检查结果**:
✓ 自检通过: <passed_count>/<total_count>项
✓ 格式验证: 通过
✓ 数据完整性: 验证通过
✓ ID唯一性: 验证通过

📁 **文件状态**:
- project.context.md: 已更新 (<current_size> lines)
- context.archive.md: <archive_status>

⏰ **下次归档提醒**: 
<archive_reminder_message>
```

### 错误处理输出
```
**⚠️ 记录过程中发现问题!**

🔍 **问题详情**:
- 错误类型: <error_type>
- 影响范围: <affected_areas>
- 错误描述: <detailed_description>

🛠️ **处理措施**:
- 已执行回滚: <rollback_status>
- 数据完整性: <integrity_status>
- 建议操作: <recommended_actions>

📞 **需要用户确认**:
<user_confirmation_required>
```

## 与超级大脑系统集成

### 系统激活集成
```yaml
激活方式:
  统一入口: 通过 super-brain-system.mdc 统一激活
  自动激活: 超级大脑系统激活时自动激活记录员
  
  注意: 记录员系统不提供独立激活入口
        所有激活逻辑已统一到 super-brain-system.mdc

协作模式:
  - 超级大脑负责决策和执行
  - 记录员负责记忆和追踪
  - 反馈系统负责用户交互
  - 三者形成完整的智能工作流
```

### 数据流集成
```yaml
输入来源:
  - 超级大脑系统的决策输出
  - 用户与AI的对话内容
  - 代码提交和项目变更
  - 问题解决过程记录

输出目标:
  - project.context.md (当前状态)
  - context.archive.md (历史记录)
  - 超级大脑系统的上下文输入
  - 用户的项目状态报告
```

### 智能联动规则
```yaml
联动场景:
  1. 项目启动时:
     超级大脑 → 项目分析 → 记录员 → 初始化文档
  
  2. 开发过程中:
     用户需求 → 超级大脑 → 决策执行 → 记录员 → 记录更新
  
  3. 问题解决时:
     问题发现 → 超级大脑 → 解决方案 → 记录员 → 经验记录
  
  4. 阶段完成时:
     里程碑达成 → 超级大脑 → 总结评估 → 记录员 → 归档整理
```

## 使用指南

### 系统启动
```
激活方式: 通过"启动超级大脑系统"自动激活记录员系统
系统响应: 自动创建 project.context.md 和 context.archive.md

注意: 记录员系统作为超级大脑系统的子系统运行
      不支持独立激活，确保系统集成的一致性
```

### 常用指令
```
/record - 手动触发增量合并
/archive - 手动触发快照归档
/record-status - 查看当前记录状态
/rollback - 回滚最后一次操作
```

### 最佳实践
```yaml
建议使用场景:
  - 复杂项目的长期开发
  - 多人协作的团队项目
  - 需要详细记录的重要项目
  - 学习和经验积累的项目

注意事项:
  - 定期检查文档完整性
  - 及时确认重要决策
  - 保持证据链接的有效性
  - 适时进行归档整理
```

## 第8层 - 性能优化与安全规则

### 大文件处理优化规则
```yaml
文件大小检测:
  操作前检查:
    - 读取 project.context.md 前先获取文件大小
    - 如果文件 > 1MB，启用分块处理模式
    - 记录文件大小到操作日志

分块操作策略:
  区块定位:
    - 使用正则表达式 /^## / 定位区块边界
    - 只读取需要修改的目标区块内容
    - 保持其他区块完全不变

  内存优化:
    - 优先使用 update_file 工具进行增量更新
    - 避免使用 write_to_file 进行全文件重写
    - 处理完成后立即释放大文件内容引用
    - 使用流式处理而非一次性加载全文件

缓存机制:
  三级缓存策略:
    L1 - 内存缓存: 最近访问的文件内容（最多3个文件，5分钟有效）
      * 失效策略: 会话结束或30分钟无活动
      * 监控指标: 命中率、内存使用量、访问频率
    L2 - 解析缓存: 区块结构解析结果（避免重复解析）
      * 失效策略: 文件修改时间变更或24小时过期
      * 版本控制: 基于文件哈希的缓存键
    L3 - 模板缓存: 远程模板本地缓存（24小时有效期）
      * 失效策略: 模板文件更新或7天过期
      * 智能预热: 根据使用频率自动预加载
  
  缓存性能优化:
    - 缓存命中率监控（目标>85%）
    - 自动清理低频访问缓存
    - 内存压力下的优雅降级
    - 缓存统计和性能报告
```

### 并发安全机制
```yaml
文件锁机制:
  锁文件检查:
    - 操作前检查是否存在 .context.lock 文件
    - 锁文件格式: JSON，包含进程ID、时间戳、操作类型
    - 如存在活跃锁，等待30秒或提示用户稍后重试

  锁定流程:
    1. 创建 .context.lock 文件标记操作开始
    2. 写入当前操作信息和预估完成时间
    3. 执行文件操作
    4. 操作完成后立即删除锁文件

  超时处理:
    - 默认操作超时: 30秒
    - 大文件操作超时: 60秒
    - 归档操作超时: 120秒
    - 超时后自动释放锁并记录警告

原子操作保障:
  安全写入策略:
    1. 重要操作前自动备份原文件为 .project.context.backup
    2. 使用临时文件进行修改操作
    3. 验证文件格式和完整性
    4. 原子性重命名替换原文件
    5. 操作失败时自动恢复备份文件

  备份管理:
    - 保留最近3个备份文件
    - 备份文件命名: .project.context.backup.1, .backup.2, .backup.3
    - 成功操作后轮转备份文件
```

### 错误恢复与回滚机制
```yaml
错误检测:
  自动检测条件:
    - 文件格式验证失败
    - 必要区块缺失或损坏
    - 操作中断或异常终止
    - 文件大小异常变化

恢复策略:
  自动恢复:
    1. 检测到错误立即停止当前操作
    2. 从最近的备份文件恢复
    3. 记录错误原因和恢复过程
    4. 通知用户恢复结果

  手动回滚:
    - /rollback --to backup1 (回滚到指定备份)
    - /rollback --steps 1 (回滚指定步数)
    - /rollback --auto (自动选择最佳回滚点)

操作日志:
  记录内容:
    - 操作时间戳和类型
    - 文件变更前后大小
    - 操作成功/失败状态
    - 错误信息和恢复动作
  
  日志文件: .context-operations.log
  保留期限: 30天
```

### 性能监控与优化
```yaml
性能指标监控:
  关键指标:
    - 文件读写操作耗时
    - 内存使用峰值
    - 并发操作冲突次数
    - 缓存命中率

  性能阈值:
    - 单次操作耗时 > 5秒: 记录性能警告
    - 文件大小 > 2MB: 建议归档
    - 并发冲突 > 3次/小时: 建议优化操作频率

自适应优化:
  动态调整:
    - 根据文件大小自动调整缓存策略
    - 基于操作频率优化锁定超时时间
    - 根据系统负载调整并发限制

  优化建议:
    - 大文件自动建议分块处理
    - 高频操作建议批量处理
    - 长时间操作建议后台执行
```

---

**记录员系统 v2.0 - 让AI永远记住项目的每一个重要时刻**
*新增：性能优化、并发安全、错误恢复机制*

## 第8层 - 输出规范

### 敏感信息保护机制 (缺陷#25修复)
```yaml
敏感信息识别:
  API密钥和凭证:
    - 模式: /api[_-]?key|apikey|api.?secret/i
    - 示例: "api_key=sk_test_123456", "API密钥: abc123def456"
    - 处理: 自动检测并脱敏处理
  
  密码和认证信息:
    - 模式: /password|passwd|pwd|secret|credential/i
    - 示例: "密码: admin123", "password=mypass"
    - 处理: 完全移除或替换为 [REDACTED]
  
  令牌和授权码:
    - 模式: /token|authorization|bearer|jwt/i
    - 示例: "Bearer eyJhbGc..."
    - 处理: 保留前4个字符 + **** (如 "eyJ****")
  
  数据库连接信息:
    - 模式: /(mysql|postgresql|mongodb):[\/\/]?/
    - 示例: "mysql://user:pass@localhost:3306/db"
    - 处理: 移除密码部分，保留结构信息
  
  个人身份信息:
    - 模式: /\d{3}-\d{2}-\d{4}|\d{15,16}/ (SSN/信用卡)
    - 示例: "身份证: 110101199003071234"
    - 处理: 保留前4位和后2位，中间用 **** 替换
  
  IP地址和服务器信息:
    - 模式: /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/
    - 敏感判断: 私有IP不脱敏 (192.168.*, 10.*, 172.16-31.*)
    - 公开IP: 脱敏处理 (如 203.***.***.***)

敏感信息扫描规则:
  触发时机:
    - 每次添加内容到 Decisions/Pinned/Done 区块时
    - 每次执行 /archive 或 /record 操作时
    - 定期批量扫描 (每天凌晨2点)
  
  扫描范围:
    - 所有项目记录文件 (project.context.md)
    - 所有归档文件 (context.archive*.md)
    - 日志文件 (.context-operations.log)
    - 临时备份文件 (.backup)
  
  扫描深度:
    - L1 (快速): 仅扫描已知敏感词列表 (30秒内)
    - L2 (标准): 正则表达式模式匹配 (2分钟内)
    - L3 (深度): 机器学习模型分析 (可选，>5分钟)

敏感信息脱敏规则:
  脱敏等级 (根据风险程度):
    Critical (0分):
      - API密钥、密码、令牌: [REDACTED]
      - 完全移除，不保留任何特征
    
    High (1分):
      - 数据库连接信息: user:****@host:port/db
      - 保留结构，移除认证信息
    
    Medium (2分):
      - 个人身份信息: ****-****-****-1234
      - 保留部分特征便于追踪
    
    Low (3分):
      - 服务器IP: 203.***.***.**
      - 保留头部便于识别网段

脱敏输出示例:
  原始: "连接数据库: mysql://admin:password123@db.example.com:3306/mydb"
  脱敏: "连接数据库: mysql://***:****@db.example.com:3306/mydb"
  
  原始: "API密钥: sk_live_4eC39HqLyjWDarht7D3Tb"
  脱敏: "API密钥: [REDACTED]"
  
  原始: "用户ID: 110101199003071234"
  脱敏: "用户ID: 1101****003071**"

脱敏后的内容管理:
  记录保护:
    - 脱敏后的内容在 project.context.md 中永久保存
    - 原始敏感信息不写入任何文件
    - 敏感信息检测日志不包含具体值
  
  备份保护:
    - 备份文件也进行脱敏处理
    - 敏感信息不存储在 .backup 文件中
  
  归档保护:
    - 迁移到 context.archive*.md 时自动脱敏
    - 历史记录中也不包含原始敏感信息

敏感信息警告和提示:
  自动检测后的处理:
    1. 在 Notes 中添加警告: ⚠️ **警告**: 检测到敏感信息已自动脱敏
    2. 提示用户具体位置: "在 Decisions 中检测到 API 密钥，已替换为 [REDACTED]"
    3. 提供安全建议: "建议立即轮换该 API 密钥"
  
  交互提示:
    用户输入包含疑似敏感信息时:
    "🔐 **安全提示**: 检测到可能的敏感信息
     - 类型: API 密钥
     - 位置: Decisions 第2条
     - 处理: 自动脱敏为 [REDACTED]
     
     ✅ 确认脱敏处理
     ❌ 取消此次操作
     🔍 查看详情"

敏感信息泄露事件日志:
  日志文件: .context-security-log
  记录内容 (不包含具体敏感值):
    - 时间戳
    - 检测到的敏感信息类型
    - 发现位置 (文件、行号、区块)
    - 脱敏处理方式
    - 操作者身份 (User/AI)
  
  日志保留策略:
    - 最多保留3个月的日志
    - 定期审核和清理
    - 生成月度安全报告

与其他规则的协调:
  与commit.mdc协调:
    - 提交时自动检查是否包含敏感信息
    - 阻止包含敏感信息的提交
    - 提示用户修改后重试
  
  与code-quality-check.mdc协调:
    - 质量检查包含敏感信息扫描
    - 作为质量门禁的一部分
    - 不允许包含敏感信息的代码通过审查

合规性保障:
  数据保护法规:
    - GDPR: 个人数据必须脱敏处理
    - CCPA: 消费者隐私信息必须保护
    - 本地法规: 根据地区要求调整
  
  安全标准:
    - OWASP Top 10: 避免敏感数据暴露
    - PCI DSS: 支付信息必须脱敏
    - SOC 2: 审计日志中不记录敏感信息
```

### 自检要点清单
```

## 第9层 - 边界情况处理 (MEDIUM 缺陷修复：#29-42)

### 缺陷#29 - 字符编码处理 (Character Encoding Handling)
```yaml
编码问题:
  支持的编码格式:
    - UTF-8 (默认推荐)
    - UTF-16
    - ISO-8859-1
    - GBK/GB18030 (中文)
    - ASCII

编码检测和转换:
  自动检测流程:
    1. 读取文件首字节检查BOM
    2. 分析文本特征确定编码
    3. 尝试UTF-8解码
    4. 若失败，尝试其他编码
    5. 最后使用 ISO-8859-1 (包含所有字节)

编码转换规则:
  输入时:
    - 自动检测输入编码
    - 转换为UTF-8内部表示
    - 保留原始编码信息
  
  输出时:
    - 统一使用UTF-8输出
    - 对特殊字符进行转义 (如需要)
    - 保持可读性

错误处理:
  - 编码错误时，使用替代字符 (U+FFFD)
  - 记录编码错误到日志
  - 提示用户检查文件编码
```

### 缺陷#30 - 时间戳精度 (Timestamp Precision)
```yaml
时间戳精度标准:
  格式: YYYY-MM-DD HH:MM:SS.mmm ±TIMEZONE
  示例: 2025-01-31 14:30:45.123 +08:00

时间戳生成:
  精度要求:
    - 秒级: 正常操作 (标准)
    - 毫秒级: 高精度需求 (可选)
    - 微秒级: 性能敏感操作 (不推荐)

时间戳验证:
  检查项:
    - 格式是否符合标准
    - 年月日是否有效
    - 小时分钟秒是否有效
    - 时区偏移是否正确

时间戳顺序检查:
  规则:
    - 同一操作内时间戳必须递增
    - 不同操作的时间戳应合理
    - 检测到时间逆转时发出警告

系统时间校准:
  - 定期与NTP服务器同步
  - 检测到系统时间跳跃时发出告警
  - 时间异常时使用递增逻辑时间
```

### 缺陷#31 - 特殊字符处理 (Special Character Handling)
```yaml
特殊字符分类:
  1. 控制字符 (ASCII 0-31, 127):
     - 处理: 转义或删除
     - 示例: \n, \t, \r
  
  2. Unicode 补充字符:
     - 处理: 使用代理对表示
     - 范围: U+10000 到 U+10FFFF
  
  3. 零宽字符:
     - 零宽空格 (U+200B)
     - 零宽连接符 (U+200D)
     - 处理: 删除或标记
  
  4. 方向标记:
     - RTL标记 (U+202E)
     - LTR标记 (U+202D)
     - 处理: 保留，用于多语言支持

特殊字符转义规则:
  在JSON中:
    - " → \"
    - \ → \\
    - \n → \\n
    - \t → \\t
  
  在URL中:
    - 使用百分比编码 (%XX)
  
  在Markdown中:
    - * → \*
    - [ → \[
    - _ → \_

特殊字符验证:
  - 检测隐藏字符和不可见字符
  - 检测异常字符组合 (如RTL注入)
  - 警告用户潜在的显示问题
```

### 缺陷#32 - 大文件处理 (Large File Handling)
```yaml
大文件定义:
  - 普通文件: < 10MB
  - 大文件: 10MB - 100MB
  - 超大文件: > 100MB

处理策略:
  分块处理:
    块大小: 512KB
    处理流程:
      1. 打开文件流
      2. 逐块读取数据
      3. 处理每个块
      4. 累积结果
      5. 关闭文件流
  
  内存优化:
    - 不一次性加载整个文件
    - 使用流式处理
    - 及时释放已处理数据
  
  进度跟踪:
    - 显示处理进度百分比
    - 估计剩余时间
    - 允许用户取消操作

大文件索引:
  - 创建行号索引便于快速定位
  - 定期更新索引（每100MB）
  - 检测文件修改时重建索引

性能优化:
  - 使用二进制搜索快速定位
  - 并行处理多个块 (如适用)
  - 缓存频繁访问的数据
```

### 缺陷#33 - 并发访问处理 (Concurrency Handling)
```yaml
并发场景:
  1. 多个用户同时写入
  2. 一个用户读，另一个用户写
  3. 多个AI实例同时操作
  4. 系统维护与用户操作冲突

锁机制:
  文件锁:
    - 共享锁 (读操作)
    - 独占锁 (写操作)
    - 获取时间: 操作开始
    - 释放时间: 操作完成
  
  锁超时:
    - 默认: 30秒
    - 超时后: 自动释放并记录错误
    - 防止死锁

冲突解决:
  写写冲突:
    - 先到先得
    - 后续操作者收到 "资源被锁定" 错误
    - 重试机制: 最多重试3次，每次延迟1秒
  
  读写冲突:
    - 读操作不阻塞其他读
    - 写操作必须等待所有读完成
    - 写操作会阻塞新的读操作

版本控制:
  - 记录每个版本的作者和时间戳
  - 保留冲突版本便于手动合并
  - 3向合并策略 (base/local/remote)
```

### 缺陷#34 - 备份和恢复机制 (Backup & Recovery)
```yaml
备份策略:
  自动备份:
    - 频率: 每小时一次
    - 保留: 最近7天的备份
    - 大小限制: 总计最多500MB
  
  手动备份:
    - 用户可随时触发 /backup 命令
    - 备份时添加标签和描述
    - 手动备份永久保留

备份存储:
  位置: .backup/ 目录
  命名: {timestamp}_{label}.backup
  格式: 压缩存档（gzip）

恢复流程:
  1. 列出可用备份
  2. 选择目标备份
  3. 验证备份完整性
  4. 创建恢复前快照
  5. 执行恢复
  6. 验证恢复结果

恢复验证:
  - 检查文件完整性
  - 验证数据一致性
  - 检查所有区块完整
  - 确认没有数据丢失

灾难恢复:
  - 数据库损坏: 使用最近的完整备份
  - 部分数据丢失: 恢复到备份点
  - 无备份可用: 尝试从git历史恢复
```

### 缺陷#35 - 日志记录完整性 (Logging Completeness)
```yaml
日志类型:
  操作日志 (.context-operations.log):
    - 记录所有操作（读、写、删除）
    - 包含时间戳、操作者、操作类型
  
  错误日志 (.context-errors.log):
    - 记录所有错误和异常
    - 包含堆栈跟踪和上下文信息
  
  审计日志 (.context-audit-log):
    - 记录权限检查和安全相关操作
    - 用于合规性审查
  
  性能日志 (.context-performance.log):
    - 记录操作性能指标
    - 用于性能分析和优化

日志轮换:
  大小限制: 单个日志文件 <= 100MB
  时间限制: 每天午夜轮换
  保留策略: 最多保留30个日志文件

日志压缩:
  - 老日志自动gzip压缩
  - 保留最近7天未压缩
  - 压缩日志后缀: .gz

日志查询:
  - 按时间范围查询
  - 按操作类型查询
  - 按操作者查询
  - 按关键字查询
```

### 缺陷#36 - 缓存管理 (Cache Management)
```yaml
缓存类型:
  1. 内存缓存 (L1):
     - 最近访问的文件内容
     - 大小限制: 100MB
     - TTL: 5分钟
  
  2. 磁盘缓存 (L2):
     - 处理过的数据快照
     - 大小限制: 500MB
     - TTL: 1小时

缓存键生成:
  - 文件路径 + 修改时间 + 内容哈希
  - 确保缓存准确性

缓存失效:
  主动失效:
    - 文件被修改时
    - 配置更改时
    - 明确调用 /clear-cache
  
  被动失效:
    - TTL过期
    - 容量满时删除最旧项
    - 周期性验证 (每1小时)

缓存统计:
  - 命中率 (%)
  - 未命中率 (%)
  - 平均命中时间 (ms)
  - 缓存占用空间 (MB)

缓存优化:
  - 预加载常用数据
  - 自适应TTL （基于访问频率）
  - 热数据提升优先级
```

### 缺陷#37 - 数据验证框架 (Data Validation)
```yaml
验证规则:
  1. 结构验证:
     - 所有必需字段存在
     - 字段类型正确
     - 嵌套结构有效
  
  2. 内容验证:
     - 字符串长度限制
     - 数值范围检查
     - 日期合理性检查
  
  3. 业务逻辑验证:
     - 引用有效性
     - 状态转换合法性
     - 权限一致性

验证失败处理:
  - 拒绝无效数据
  - 记录验证错误
  - 提示用户纠正
  - 可选的自动修复

验证性能:
  - 缓存验证规则
  - 并行验证多个项
  - 短路评估 (发现错误即停止)

自定义验证:
  - 允许插件扩展验证
  - 支持正则表达式验证
  - 支持自定义验证函数
```

### 缺陷#38 - 监控和告警 (Monitoring & Alerting)
```yaml
监控指标:
  系统健康:
    - 平均响应时间
    - 错误率
    - 资源使用率
  
  数据质量:
    - 数据完整性
    - 一致性检查结果
    - 异常数据比例

告警规则:
  立即告警 (Critical):
    - 无法访问主文件
    - 数据损坏检测
    - 权限冲突
  
  高优先级 (High):
    - 响应时间 > 1秒
    - 错误率 > 1%
    - 磁盘使用 > 80%
  
  普通告警 (Medium):
    - 响应时间 > 500ms
    - 缓存命中率 < 50%
    - 日志文件大小 > 50MB

告警通知:
  - 邮件通知
  - 日志记录
  - 仪表板显示
  - 外部集成 (如Slack)

告警消息格式:
  标题: [严重程度] 告警类型
  内容:
    - 发生时间
    - 影响范围
    - 建议操作
```

### 缺陷#39 - 用户提示和反馈 (User Prompts & Feedback)
```yaml
提示类型:
  信息提示:
    - 操作成功确认
    - 友好的状态信息
  
  警告提示:
    - 即将执行危险操作
    - 性能警告
  
  错误提示:
    - 操作失败原因
    - 建议的纠正措施
  
  确认提示:
    - 删除操作确认
    - 覆盖确认
    - 大操作确认

提示格式:
  结构化提示:
    ```
    📋 **操作**: 描述
    ⚠️ **风险**: 可能的风险
    ✅ **确认**: 是/否/了解
    ```
  
  进度提示:
    ```
    ⏳ **进度**: [=====>    ] 45%
    ⏱️ **已用**: 1分30秒
    ⏲️ **预计**: 3分00秒
    ```

反馈收集:
  - 操作完成后询问满意度
  - 收集改进建议
  - 记录用户反馈
  - 定期分析反馈趋势

交互式帮助:
  - 提供相关文档链接
  - 显示示例命令
  - 建议下一步操作
```

### 缺陷#40 - 插件和扩展框架 (Plugin & Extension)
```yaml
扩展点:
  1. 数据处理扩展:
     - 自定义验证规则
     - 自定义转换逻辑
  
  2. 输出格式扩展:
     - 自定义报告格式
     - 自定义导出格式
  
  3. 存储扩展:
     - 支持不同存储后端
     - 支持云存储集成
  
  4. 通知扩展:
     - 自定义告警通知
     - 第三方集成

插件标准接口:
  - 统一的初始化接口
  - 标准的事件钩子
  - 版本兼容性机制

插件安全:
  - 沙箱隔离
  - 权限声明
  - 签名验证
  - 性能限制

插件管理:
  /plugin-list - 列出已安装插件
  /plugin-install [url] - 安装插件
  /plugin-uninstall [name] - 卸载插件
  /plugin-config [name] - 配置插件
```

### 缺陷#41 - API标准化 (API Standardization)
```yaml
命令前缀标准:
  /record - 记录操作
  /archive - 归档数据
  /sync - 同步系统
  /export - 导出数据
  /diagnose - 诊断系统
  /config - 配置系统

参数标准:
  - 使用 -- 前缀长选项
  - 使用 - 前缀短选项
  - 统一的参数名称

返回值标准:
  成功响应:
    {
      status: "success",
      data: { ... },
      message: "操作完成"
    }
  
  错误响应:
    {
      status: "error",
      error_code: "ERR_001",
      message: "详细错误信息",
      details: { ... }
    }

错误代码标准:
  - ERR_001: 参数无效
  - ERR_002: 权限不足
  - ERR_003: 资源不存在
  - ERR_004: 操作冲突
  - ERR_005: 系统错误
```

### 缺陷#42 - 完整性检查 (Integrity Verification)
```yaml
检查维度:
  1. 结构完整性:
     - 所有必需区块存在
     - 区块内容格式有效
  
  2. 数据完整性:
     - 无重复条目
     - 无悬空引用
     - 关联关系一致
  
  3. 一致性检查:
     - 主备文件同步
     - 版本号一致
     - 时间戳递增

检查触发时机:
  - 系统启动时
  - 加载新文件时
  - 大操作后
  - 定期检查 (每6小时)
  - 用户手动请求

检查结果处理:
  通过: 正常继续
  警告: 记录并继续，提示用户
  错误: 中止操作，要求修复
  致命: 阻止系统启动，需要恢复

自动修复:
  - 修复损坏的格式
  - 清理重复条目
  - 重建索引
  - 修复时间戳

手动修复:
  - 提供详细的问题报告
  - 建议修复步骤
  - 提供恢复工具
```