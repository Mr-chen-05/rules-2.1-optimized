---
type: "global_rule"
description: "记忆系统集成 - 项目记忆存储、管理和智能使用"
globs: ["**/*"]
priority: 930
alwaysApply: false

# Version Management
version: "2.6.0"
last_updated: "2025-10-18"
author: "system"
status: "stable"
compatibility: "rule-system >= 2.0"

changelog:
  - version: "2.6.0"
    date: "2025-10-18"
    changes:
      - "P0-2: 新增Memory使用授权机制"
      - "添加Recorder vs Memory决策树"
      - "实现敏感信息过滤和数据脱敏"
---

# 💾 记忆系统集成

> **智能记忆**: 项目全生命周期记忆管理，支持智能检索和上下文感知

## 🎯 系统概述

记忆系统是可选的协作组件，主要用于语义模糊检索与跨项目/跨时间的关联聚合。默认情况下，日常的历史记录与精准查询由记录员系统（Recorder）承担；当需要模糊语义检索或跨范围聚合时，再按需联动记忆系统以增强上下文检索能力。

## 记忆系统集成配置

记忆系统作为可选协作组件，主要用于语义模糊检索与跨项目/跨时间关联聚合。

**核心原则**: Recorder优先，Memory可选

**优先级策略明确化**:
- **主要职责分工**:
  * Recorder: 精确记录、结构化存储、项目上下文管理
  * Memory: 语义检索、跨项目关联、长期知识积累
- **决策优先级**:
  1. 项目内精确查询 → 优先使用Recorder
  2. 跨项目语义检索 → 优先使用Memory
  3. 实时记录和更新 → 强制使用Recorder
  4. 历史模式分析 → 优先使用Memory
- **冲突解决机制**:
  * 数据一致性冲突时，以Recorder为准
  * 功能重叠时，优先调用Recorder
  * Memory故障时，系统完全依赖Recorder运行

## 🏗️ 记忆架构

### 记忆层次结构
```yaml
记忆层次:
  L1_会话记忆:
    范围: 当前对话会话
    生命周期: 会话结束时清除
    内容: 临时交互、即时决策
  
  L2_项目记忆:
    范围: 单个项目全生命周期
    生命周期: 项目完成后归档
    内容: 项目状态、阶段信息、技术决策
  
  L3_全局记忆:
    范围: 跨项目经验和知识
    生命周期: 永久保存
    内容: 最佳实践、模式库、用户偏好
  
  L4_学习记忆:
    范围: AI系统自我优化
    生命周期: 持续更新
    内容: 算法参数、性能指标、优化策略
```

### MCP Memory工具集成
```yaml
MCP记忆工具使用:
  实体创建:
    触发条件:
      - 新项目启动
      - 重要技术决策
      - 关键里程碑达成
      - 问题解决方案
    
    实体类型:
      - Project: 项目基本信息
      - Phase: 项目阶段状态
      - Decision: 技术决策记录
      - Solution: 解决方案记录
      - User: 用户偏好和习惯
  
  关系建立:
    关系类型:
      - belongs_to: 归属关系
      - depends_on: 依赖关系
      - leads_to: 导致关系
      - similar_to: 相似关系
      - conflicts_with: 冲突关系
  
  观察记录:
    记录机制（按需可配置）:
      - 结构化记录优先采用 Recorder（默认）：Facts/Decisions/TODO/Notes 分类
      - 需要语义检索或聚合时：将关键片段同步到 Memory（可选）
      - 可配置的记录触发：按需启用、可关闭、不影响系统正常使用
```

## 📝 记录机制（按需）

### 触发条件详细定义
```yaml
建议记录触发（可按需启用）:
  项目生命周期事件:
    - 项目创建: 记录项目基本信息和初始需求
    - 阶段切换: 保存当前阶段成果和下阶段计划
    - 项目完成: 归档项目总结和经验教训
    - 项目暂停/恢复: 记录状态变更原因
  
  技术决策事件:
    - 技术栈选择: 记录选择理由和替代方案
    - 架构设计: 保存设计方案和权衡考虑
    - 工具选择: 记录工具评估和使用效果
    - 性能优化: 保存优化策略和效果评估
  
  问题解决事件:
    - Bug发现和修复: 记录问题描述和解决方案
    - 性能瓶颈: 保存分析过程和优化结果
    - 集成问题: 记录集成挑战和解决策略
    - 部署问题: 保存部署经验和最佳实践
  
  用户交互事件:
    - 重要确认: 记录用户确认的关键决策
    - 偏好表达: 保存用户技术偏好和习惯
    - 反馈意见: 记录用户满意度和改进建议
    - 学习需求: 保存用户知识盲点和学习计划
```

### 记录内容标准
```yaml
记录格式:
  基础信息:
    - 时间戳: ISO 8601格式
    - 项目ID: 唯一标识符
    - 阶段标识: 当前项目阶段
    - 用户ID: 用户唯一标识
  
  内容结构:
    - 事件类型: 分类标签
    - 事件描述: 详细说明
    - 上下文信息: 相关背景
    - 结果评估: 效果和影响
    - 关联实体: 相关项目、决策等
  
  元数据:
    - 重要性级别: 1-5级评分
    - 可信度: 信息准确性评估
    - 更新频率: 信息变更频率
    - 访问权限: 信息共享范围
```

## 🔍 智能检索系统

### 检索策略
```yaml
检索算法:
  语义检索:
    - 基于向量相似度的语义匹配
    - 支持自然语言查询
    - 上下文感知的结果排序
  
  关联检索:
    - 基于实体关系的关联查找
    - 支持多跳关系推理
    - 时间序列相关性分析
  
  模式检索:
    - 基于历史模式的预测性检索
    - 支持相似场景的经验复用
    - 异常模式的识别和预警
  
  混合检索:
    - 多种检索策略的智能组合
    - 动态权重调整和优化
    - 个性化检索结果定制
```

### 检索优化
```yaml
性能优化:
  索引策略:
    - 多维度索引构建
    - 增量索引更新
    - 分布式索引管理
  
  缓存机制:
    - 热点数据缓存
    - 预测性数据预加载
    - 智能缓存淘汰策略
  
  查询优化:
    - 查询重写和优化
    - 并行查询执行
    - 结果去重和合并
```

## 🧠 上下文感知

### 上下文构建
```yaml
上下文要素:
  当前状态:
    - 项目阶段和进度
    - 技术栈和架构
    - 团队规模和技能
    - 时间和资源约束
  
  历史轨迹:
    - 过往决策和结果
    - 问题解决历程
    - 学习和改进过程
    - 用户反馈和偏好
  
  环境因素:
    - 技术趋势和最佳实践
    - 行业标准和规范
    - 工具生态和兼容性
    - 安全和合规要求
```

### 上下文应用
```yaml
智能应用:
  决策支持:
    - 基于历史经验的决策建议
    - 风险评估和预警
    - 替代方案的比较分析
  
  个性化服务:
    - 用户偏好的自动适配
    - 个性化工作流推荐
    - 定制化界面和交互
  
  预测性分析:
    - 项目风险预测
    - 资源需求预估
    - 时间线预测和调整
```

## 🔄 记忆同步和一致性

### 同步机制
```yaml
同步策略:
  实时同步:
    - 关键事件的即时记录
    - 状态变更的实时更新
    - 冲突检测和解决
  
  批量同步:
    - 非关键信息的批量处理
    - 定期数据整理和归档
    - 性能优化的延迟更新
  
  增量同步:
    - 变更数据的增量传输
    - 版本控制和回滚支持
    - 数据完整性验证
```

### 一致性保证
```yaml
一致性级别:
  强一致性:
    - 关键决策和状态信息
    - 项目阶段和里程碑
    - 用户确认和授权
  
  最终一致性:
    - 统计数据和分析结果
    - 学习模型和参数
    - 缓存和索引信息
  
  弱一致性:
    - 日志和调试信息
    - 临时状态和中间结果
    - 性能监控数据
```

## 📊 记忆分析和洞察

### 分析维度
```yaml
分析类型:
  趋势分析:
    - 项目成功率趋势
    - 技术选择演变
    - 用户行为模式
  
  关联分析:
    - 技术栈与项目成功的关联
    - 团队规模与效率的关系
    - 问题类型与解决时间的相关性
  
  异常检测:
    - 项目进度异常
    - 性能指标异常
    - 用户行为异常
  
  预测分析:
    - 项目成功概率预测
    - 资源需求预测
    - 风险发生概率预测
```

### 洞察应用
```yaml
洞察输出:
  报告生成:
    - 项目总结报告
    - 性能分析报告
    - 改进建议报告
  
  可视化展示:
    - 项目进度仪表板
    - 技术栈使用统计
    - 问题解决效率图表
  
  智能推荐:
    - 基于历史数据的最佳实践推荐
    - 个性化工具和方法建议
    - 风险预防和缓解策略
```

## 🛡️ 隐私和安全

### 数据保护
```yaml
安全措施:
  数据加密:
    - 传输过程加密
    - 存储数据加密
    - 密钥管理和轮换
  
  访问控制:
    - 基于角色的权限管理
    - 细粒度访问控制
    - 审计日志和监控
  
  隐私保护:
    - 敏感信息脱敏
    - 数据最小化原则
    - 用户同意和控制
```

### 合规要求
```yaml
合规标准:
  数据治理:
    - 数据分类和标记
    - 生命周期管理
    - 质量监控和改进
  
  法规遵循:
    - GDPR合规性
    - 数据本地化要求
    - 行业特定规范
  
  透明度:
    - 数据使用说明
    - 算法可解释性
    - 用户权利保障
```

---

## 🔒 Memory 使用授权机制（2025安全增强版）

### 授权分类

```yaml
自动使用 (无需授权):
  - 仅读取已有 Memory 数据
  - 搜索公开知识节点
  - 查询非敏感信息
  - 检索历史模式和经验
  - 示例: "根据Memory中的历史经验..."

需要授权 (必须询问用户):
  - 创建新的 Memory 实体
  - 写入项目相关信息
  - 记录技术决策和方案
  - 建立跨项目关联关系
  - 存储用户偏好设置
  - 示例: "是否将此决策记录到Memory？"

禁止使用 (直接拒绝):
  - 存储敏感信息 (密码、密钥、API token)
  - 记录商业机密和保密信息
  - 存储个人隐私数据 (联系方式、身份信息)
  - 未经脱敏的真实生产数据
  - 示例: "该信息包含敏感数据，不会存入Memory"
```

### 授权话术模板

```yaml
标准授权请求:
  "我建议将以下信息记录到 Memory 系统以便长期保存和跨会话检索：
   
   📝 待记录内容:
   - 实体: [实体名称]
   - 类型: [实体类型 - 技术/业务/架构等]
   - 关系: [与其他实体的关联]
   - 说明: [简要描述]
   
   ⚠️ Memory 说明:
   - 数据将持久化存储在您的本地 Memory 系统
   - 可跨会话和项目进行语义检索
   - 您随时可以查看、编辑或删除
   - 该数据仅存储在本地，不会上传
   
   是否授权记录到 Memory？(回复 yes/y 确认，no/n 拒绝)"

简化授权请求 (快速场景):
  "💾 是否将 [实体名称] 记录到 Memory 以便后续快速检索？(y/n)"

拒绝存储说明:
  "⚠️ 该信息包含 [敏感数据类型]，出于安全考虑不会存入 Memory。
   ✅ 已记录到 Recorder (project.context.md) 供本项目使用。"
```

### Recorder vs Memory 决策树

```yaml
决策流程:
  用户请求记录信息:
    ↓
  信息分类:
    ├─ 敏感信息 (密码/密钥/隐私)
    │  └→ 仅记录到 Recorder (不进Memory)
    │     └→ 提示: "已安全记录到本地项目文件"
    │
    ├─ 本地项目信息 (代码/配置/决策)
    │  └→ 优先 Recorder (project.context.md)
    │     └→ 可选: 询问是否同时存入Memory
    │
    ├─ 需要跨会话搜索 (技术方案/架构模式)
    │  └→ 询问后使用 Memory
    │     └→ 提示: "将存储到Memory供长期检索"
    │
    ├─ 需要语义检索 (相似问题/经验教训)
    │  └→ 询问后使用 Memory
    │     └→ 提示: "支持模糊语义搜索"
    │
    └─ 临时信息 (草稿/待定方案)
       └→ 仅 Recorder
          └→ 提示: "临时记录，不进入Memory"

操作优先级:
  1. 敏感信息检测 → 强制仅Recorder
  2. 用户明确指定 → 遵循用户意图
  3. 信息性质判断 → 自动选择Recorder/Memory
  4. 不确定时 → 询问用户偏好
```

### 实施示例

```yaml
示例1 - 技术决策记录 (需授权):
  用户: "我们决定使用 PostgreSQL 作为主数据库"
  AI: "收到！这是重要的技术决策。
       
       📝 建议记录方式:
       1. ✅ 已记录到 project.context.md (Recorder)
       2. 💾 是否同时记录到 Memory 以便：
          - 未来项目参考相似决策
          - 跨项目数据库选型分析
       
       是否授权记录到 Memory？(y/n)"

示例2 - 敏感信息 (自动拒绝):
  用户: "数据库密码是 Admin@123"
  AI: "⚠️ 已记录密码信息到本地加密配置文件。
       
       🔒 安全说明:
       - 敏感凭证不会存入 Memory 系统
       - 已安全存储到 Recorder 的加密区域
       - 仅您本地可访问
       
       ✅ 记录完成"

示例3 - 临时信息 (仅Recorder):
  用户: "先尝试这个方案看看效果"
  AI: "明白，这是待验证方案。
       
       📋 已记录到 Recorder 的 TODO 区域：
       - 状态: 待验证
       - 优先级: 高
       
       验证后如需长期保存，可再决定是否存入 Memory。"

示例4 - 读取Memory (无需授权):
  用户: "之前类似项目是怎么处理的？"
  AI: "让我检索 Memory 中的历史经验...
       
       🔍 找到3个相似项目的处理方案:
       [展示检索结果]
       
       这些信息来自您的 Memory 知识库。"
```

### 安全保障机制

```yaml
数据安全:
  敏感信息过滤:
    - 密码模式: /password|pwd|passwd|secret/i
    - 密钥模式: /api[_-]?key|token|credential/i
    - 隐私模式: /phone|email|address|ssn|id[_-]?card/i
    - 检测到立即拒绝存入Memory
  
  数据脱敏:
    - 存储前自动脱敏
    - IP地址 → xxx.xxx.xxx.xxx
    - 邮箱 → user@***
    - 保留结构，隐藏内容
  
  权限控制:
    - Memory 读取: 无需授权
    - Memory 写入: 需要授权
    - Memory 删除: 用户随时可执行
    - Memory 导出: 需要确认

审计追踪:
  每次 Memory 操作记录:
    - 时间戳
    - 操作类型 (read/write/delete)
    - 数据摘要 (不含敏感内容)
    - 授权状态
    - 结果状态
```

---

**💡 使用提示**: Memory 工具为可选。默认使用 Recorder 完成结构化记录与精准检索；当需要模糊语义检索或跨项目/跨时间聚合时，再使用 `/memory` 相关命令进行按需查看与管理（Recorder 优先）。写入 Memory 前必须获得用户授权，敏感信息自动拒绝存入。