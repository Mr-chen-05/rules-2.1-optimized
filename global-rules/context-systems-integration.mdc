---
type: "always_apply"
description: "Context Loader与记录员系统集成配置 - 解决功能重叠和协同工作"
priority: 900
alwaysApply: true
integrations: ["context-loader", "context-recorder-system", "super-brain-system"]

# Version Management
version: "2.6.0"
last_updated: "2025-10-19"
author: "system"
status: "stable"
compatibility: "rule-system >= 2.0"

changelog:
  - version: "2.6.0"
    date: "2025-10-19"
    changes:
      - "Add version management system"
      - "Standardize rule file structure"
---

# 🔗 Context Systems Integration - 上下文系统集成

解决 Context Loader 与记录员系统的功能重叠，实现协同工作和智能分工。

## 🎯 系统分工定义

### Context Loader (项目分析器)
```yaml
主要职责:
  - 项目技术栈识别和分析
  - 代码结构和架构模式分析
  - 开发工具和配置推荐
  - 项目健康度评估
  - 一次性深度项目分析

触发时机:
  - 首次接触新项目
  - 项目结构发生重大变化
  - 用户主动请求项目分析
  - 技术栈升级或迁移

输出内容:
  - 项目技术栈报告
  - 配置推荐建议
  - 项目健康度评分
  - 改进建议清单
```

### Context Recorder (记录员系统)
```yaml
主要职责:
  - 持续的项目进度记录
  - 决策和任务状态跟踪
  - 问题和解决方案归档
  - 增量式上下文更新
  - 长期项目记忆管理

触发时机:
  - 每次对话和任务执行
  - 重要决策制定时
  - 问题解决过程中
  - 项目里程碑达成

输出内容:
  - project.context.md (实时状态)
  - context.archive.md (历史归档)
  - 任务进度跟踪
  - 决策记录链

### Context7（知识引擎）
```yaml
主要职责:
  - 针对性知识检索与聚合（架构、接口、约束、历史决策、相关代码）
  - 在具体任务执行前进行知识预载（Bug 修复/新项目/新功能）
  - 为工作流提供“最小充分理解”所需材料
触发时机:
  - /analyze-issue、/implement-task、/frontend-dev、/backend-dev 之前
  - 检测到错误关键词或新项目初始化意图
输出内容:
  - 知识预载摘要（关键结论、文件链接、风险与约束、下一步建议）
  - 写入 project.context.md 的 Pinned/Notes，并触发用户确认
协同声明:
  - Context Loader 负责首次深度项目分析；Context7 专注于任务前置知识预载
  - 记录员系统接收预载摘要并维护连续上下文
```
```

## 🔄 协同工作流程

### 1. 项目初始化阶段
```yaml
Step 1 - Context Loader 启动:
  - 执行深度项目分析
  - 生成技术栈报告
  - 提供配置推荐
  - 评估项目健康度

Step 2 - 记录员系统接管:
  - 基于 Context Loader 分析结果初始化 project.context.md
  - 将技术栈信息记录到 Pinned 区块
  - 将配置推荐转化为 TODO 任务
  - 开始持续记录模式

集成数据流:
  Context Loader 分析结果 → 记录员系统 Pinned 区块
  配置推荐 → TODO 任务列表
  项目健康度 → Notes 区块
```

### 2. 日常开发阶段
```yaml
记录员系统主导:
  - 持续记录开发进度
  - 跟踪任务状态变化
  - 记录决策和问题解决
  - 维护项目上下文连续性

Context Loader 辅助:
  - 仅在重大变化时重新分析
  - 提供技术栈更新建议
  - 监控项目健康度变化
```

### 3. 项目重构/升级阶段
```yaml
双系统协作:
  - Context Loader 重新分析项目变化
  - 记录员系统记录重构决策过程
  - 新的分析结果更新到 project.context.md
  - 重构任务纳入 TODO 管理
```

## 🚫 冲突避免机制

### 功能边界清晰化
```yaml
Context Loader 不应该:
  - 创建或修改 project.context.md
  - 进行持续的状态跟踪
  - 记录具体的任务执行过程
  - 管理长期项目记忆

记录员系统不应该:
  - 进行深度技术栈分析
  - 提供配置推荐建议
  - 评估项目健康度
  - 分析代码架构模式
```

### 数据交换协议
```yaml
Context Loader → 记录员系统:
  数据格式: 结构化分析报告
  传递方式: 通过 Pinned 区块记录关键信息
  更新频率: 仅在重大变化时

记录员系统 → Context Loader:
  数据格式: 项目变化通知
  传递方式: 通过状态变化触发重新分析
  更新频率: 检测到重大项目变化时
```

## 🎛️ 智能路由规则

### 指令路由分配
```yaml
Context Loader 处理:
  - /load-context (所有变体)
  - /analyze-project
  - /tech-stack
  - /project-health

记录员系统处理:
  - /record
  - /init-project
  - /archive
  - /status
  - /sync

共享指令:
  - /project-overview (双系统协作)
  - /project-summary (双系统协作)
```

### 自动触发逻辑
```yaml
Context Loader 自动触发:
  - 检测到新的 package.json/requirements.txt
  - 发现新的配置文件
  - 项目结构发生重大变化
  - 依赖版本大幅更新

记录员系统自动触发:
  - 每次 AI 对话开始
  - 任务状态发生变化
  - 重要决策制定
  - 问题解决完成
```

## 📋 集成最佳实践

### 1. 项目启动最佳流程
```yaml
推荐顺序:
  1. 执行 /load-context --deep (Context Loader 深度分析)
  2. 自动触发 /init-project (记录员系统初始化)
  3. 将分析结果整合到 project.context.md
  4. 开始正常的开发记录流程
```

### 2. 定期维护流程
```yaml
每周维护:
  - 记录员系统自动归档过期内容
  - Context Loader 检查项目健康度变化

每月维护:
  - Context Loader 重新评估技术栈
  - 记录员系统生成月度项目报告
```

### 3. 错误处理机制
```yaml
冲突检测:
  - 监控两系统是否同时修改相同文件
  - 检测功能重复执行
  - 识别数据不一致问题

自动修复:
  - 优先保留记录员系统的实时数据
  - Context Loader 重新分析以同步状态
  - 生成冲突解决报告
```

## 🔧 配置参数

### 集成开关
```yaml
integration_mode: "collaborative"  # collaborative | independent | recorder_only
auto_sync: true
conflict_resolution: "recorder_priority"
analysis_frequency: "on_major_change"
```

### 性能优化
```yaml
cache_analysis_results: true
incremental_analysis: true
background_sync: true
memory_optimization: true
```

## 🧠 记忆协同策略（Recorder 优先，Memory 可选）
```yaml
默认原则:
  - 日常结构化记录与精准检索由记录员系统负责（Recorder）
  - Memory 按需启用，仅在需要模糊语义检索或跨项目/跨时间聚合时使用

协同方式:
  - 如已安装 Memory：可选择性同步关键片段以支持语义检索（可选）
  - 如未安装 Memory：不影响系统使用；继续以 Recorder 为主进行记录与检索

触发条件（建议）:
  - 用户明确提出语义检索/跨项目聚合需求
  - 需要对历史碎片化信息进行模糊匹配
  - 需要跨阶段/跨仓库的全局聚合分析
```

#### 明确的数据同步机制
```yaml
权威性定义:
  - Recorder 为主权威源：所有项目上下文和决策记录的最终真实来源
  - Memory 为辅助索引：提供语义检索和聚合能力
  - 冲突时以 Recorder 为准

数据流向:
  Recorder (主) → Memory (从)
  - 单向同步：Recorder 的数据变化定期推送到 Memory
  - Memory 接收后建立语义索引，不修改原始内容

同步时机:
  - 自动同步：每次 Recorder 执行 /archive 或 /record 后
  - 手动触发：用户执行 /sync-memory 命令
  - 定期同步：每天凌晨2点执行一次完整同步

同步内容范围:
  必须同步 (核心数据):
    - Pinned 区块所有内容
    - Decisions 区块完整决策记录
    - Done 区块已完成且关键的任务
  
  可选同步 (补充数据):
    - 高质量的 TODO 任务（质量评分 > 70分）
    - 已解决问题和解决方案
    - 项目统计数据摘要
  
  不同步 (临时数据):
    - 低质量的草稿内容（质量评分 < 50分）
    - 暂存性 Notes 备注
    - 个人用户备忘录
```

#### 冲突检测与解决
```yaml
冲突场景识别:
  场景1 - Recorder 和 Memory 同时更新同一条记录:
    检测方式：时间戳对比，如两者在10秒内更新则判定为冲突
    解决规则：保留 Recorder 版本，记录冲突日志
  
  场景2 - Memory 包含不在 Recorder 中的数据:
    检测方式：Memory 中查询，在 Recorder 中找不到对应记录
    解决规则：移除 Memory 中的孤立数据，并通知用户
  
  场景3 - Recorder 删除了 Memory 中有的内容:
    检测方式：Recorder 删除操作触发时检查 Memory
    解决规则：自动从 Memory 中删除对应内容

解决流程:
  1. 自动检测冲突（每次同步时执行）
  2. 记录冲突详情（时间戳、冲突数据摘要、解决方案）
  3. 若冲突可自动解决则立即执行
  4. 若冲突需要人工判断则通知用户并暂停同步
  5. 用户确认后继续同步或回滚
```

#### 数据一致性验证
```yaml
验证周期：
  - 实时验证：每次同步后检查
  - 每周验证：完整一致性检查（周日凌晨）
  - 每月审计：生成一致性报告（月末）

验证项目:
  1. 数据计数：Recorder 和 Memory 中的记录总数是否相同
  2. ID映射：所有 ID 在两系统中是否一一对应
  3. 时间戳：关键记录的更新时间是否一致
  4. 内容哈希：敏感内容的校验和是否相同
  5. 引用完整性：所有关联关系是否完整

异常处理:
  - 不一致项自动标记为需要人工审查
  - 每天生成一致性检查报告
  - 若不一致率超过5%则自动暂停 Memory 操作
```

---

**注意**: 此集成配置确保两个系统各司其职，避免功能重叠，实现最佳的协同效果。